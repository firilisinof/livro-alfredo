% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Índice}
\else
  \newcommand\contentsname{Índice}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{Lista de Figuras}
\else
  \newcommand\listfigurename{Lista de Figuras}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{Lista de Tabelas}
\else
  \newcommand\listtablename{Lista de Tabelas}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figura}
\else
  \newcommand\figurename{Figura}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Tabela}
\else
  \newcommand\tablename{Tabela}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listagem}
\newcommand*\listoflistings{\listof{codelisting}{Lista de Listagens}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother

\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{portuguese}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Introdução à Linguagem Julia},
  pdfauthor={Alfredo Goldman; Lucas de Sousa Rosa},
  pdflang={pt},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Introdução à Linguagem Julia}
\author{Alfredo Goldman \and Lucas de Sousa Rosa}
\date{2024-10-26}

\begin{document}
\maketitle

\renewcommand*\contentsname{Índice}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter*{TODO: adicionar prefácio ou algo do
gênero}\label{todo-adicionar-prefuxe1cio-ou-algo-do-guxeanero}
\addcontentsline{toc}{chapter}{TODO: adicionar prefácio ou algo do
gênero}

\markboth{TODO: adicionar prefácio ou algo do gênero}{TODO: adicionar
prefácio ou algo do gênero}

\bookmarksetup{startatroot}

\chapter{Visão Geral do Curso}\label{visuxe3o-geral-do-curso}

\bookmarksetup{startatroot}

\chapter{Visão Geral da Evolução de Hardware e
Linguagens}\label{visuxe3o-geral-da-evoluuxe7uxe3o-de-hardware-e-linguagens}

\bookmarksetup{startatroot}

\chapter{Usando o Interpretador (REPL) como
Calculadora}\label{usando-o-interpretador-repl-como-calculadora}

Objetivo: Ver o interpretador de Julia como uma calculadora poderosa,
introduzir a noção de variáveis.

\section{Começando com o modo interativo do
Julia}\label{comeuxe7ando-com-o-modo-interativo-do-julia}

Quem quiser já pode instalar o ambiente de programação, usem esse
\href{https://julialang.org/}{link}. Há também alguns ambientes que
permitem o uso da linguagem no seu navegador, sugiro a busca pelas
palavras chave \texttt{Julia\ Language\ online}.

Dentro do Julia (após chamar julia na linha de comando), vamos começar
com contas com números inteiros:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1} \OperatorTok{+} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{40} \OperatorTok{*} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
160
\end{verbatim}

Sim, como era de se esperar, podemos em Julia usar os operandos:
\texttt{+}, \texttt{-} e \texttt{*}, o resultado será como o esperado.
Vejamos a seguir que com a divisão fica um pouco diferente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{84} 
\NormalTok{b }\OperatorTok{=} \FloatTok{2}

\CommentTok{\# As variáveis a e b são do tipo Int64}

\NormalTok{resultado }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}
\FunctionTok{println}\NormalTok{(resultado)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42.0
\end{verbatim}

Notem que nesse caso, houve uma mudança de tipos, pois 84 e 2 são
inteiros e o resultado é um número em ponto flutuante (float), podemos
ver isso, pois ao invés de 42, tivemos como resultado 42.0.

Também é possível pedir o resultado inteiro usando o operador
\texttt{div}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{div}\NormalTok{(}\FloatTok{84}\NormalTok{,}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42
\end{verbatim}

Ou de forma equivalente usando o operador \texttt{\textbackslash{}div}
(para conseguir ver o símbolo da divisão é necessário digitar
\texttt{\textbackslash{}div} seguido da tecla
\texttt{\textless{}tab\textgreater{}}).

Além das contas básicas, também dá para fazer a exponenciação:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2}\OperatorTok{\^{}}\FloatTok{31}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2147483648
\end{verbatim}

Expressões mais complexas também podem ser calculadas:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{+} \FloatTok{2} \OperatorTok{*} \FloatTok{2} \OperatorTok{+} \FloatTok{3} \OperatorTok{*} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
39
\end{verbatim}

Sim, a precedência de operadores usual também é válida em Julia. Mas,
segue a primeira lição de programação: \emph{Escreva para humanos, não
para máquinas}.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{+}\NormalTok{ (}\FloatTok{2} \OperatorTok{*} \FloatTok{2}\NormalTok{) }\OperatorTok{+}\NormalTok{ (}\FloatTok{3} \OperatorTok{*} \FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
39
\end{verbatim}

Em Julia também podemos fazer operações com números em ponto flutuante:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23.5} \OperatorTok{*} \FloatTok{3.14}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
73.79
\end{verbatim}

ou

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{12.5} \OperatorTok{/} \FloatTok{2.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6.25
\end{verbatim}

Acima temos mais um exemplo de código escrito para pessoas, ao se
escrever 2.0 estamos deixando claro que o segundo parâmetro é um número
float.

É importante saber que números em ponto flutuante tem precisão limitada,
logo não se espante com resultados inesperados como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1.2} \OperatorTok{{-}} \FloatTok{1.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.19999999999999996
\end{verbatim}

Erros como esse são bastante raros, tanto que usualmente confiamos
plenamente nas contas feitas com computadores e calculadoras. Mas, é bom
saber que existem limitações.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2.6} \OperatorTok{{-}} \FloatTok{0.7} \OperatorTok{{-}} \FloatTok{1.9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.220446049250313e-16
\end{verbatim}

ou

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
\end{verbatim}

ou ainda

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{10e15} \OperatorTok{+} \FloatTok{1} \OperatorTok{{-}} \FloatTok{10e15}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.0
\end{verbatim}

Esses problemas de precisão estão ligados a limitação de como os números
são representados no computador. De maneira simplificada, os valores no
computador são codificados em palavras, formadas por bits. Nos
computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma
outra limitação está ligada aos números inteiros muito grandes

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2}\OperatorTok{\^{}}\FloatTok{63}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-9223372036854775808
\end{verbatim}

Mas, para um curso introdutório basta saber que existem essas
limitações. Como lidar com elas é parte de um curso mais avançado.

É importante notar que o erro acima é um \emph{erro silencioso}, ou seja
quanto estamos usando números inteiros, pode ocorrer que o número a ser
representado não caiba no número de bits disponível, o que faz com que
ocorra um erro.

Voltando para as contas. Um outro operador interessante é o \texttt{\%}
que faz o resto da divisão

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{4} \OperatorTok{\%} \FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Até agora vimos como trabalhar com um único valor, ou seja, como se
fosse no visor de uma calculadora. Mas, é possível ir além. Ao invés de
termos teclas de memória, o computador nos oferece variáveis. Elas são
como nomes para valores que queremos guardar e usar mais tarde.

Além das operações básicas também temos as operações matemáticas
(funções), como por exemplo o seno, sin em inglês. Para saber como uma
função funciona podemos pedir ajuda ao ambiente, usando uma \texttt{?}
ou o macro \texttt{@doc}, e em seguida digitando o que queremos saber,
como por exemplo em:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc}\NormalTok{ sin}
\end{Highlighting}
\end{Shaded}

A saída desse comando indica a operação que a função realiza e ainda
apresenta alguns exemplos:

\begin{verbatim}
  sin(x)

  Compute sine of x, where x is in radians.

  See also sind, sinpi, sincos, cis, asin.

  Examples
  ≡≡≡≡≡≡≡≡

  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)
  1×9 Matrix{Float64}:
   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0
\end{verbatim}

Ambos os comandos \texttt{?\ sin} \texttt{@doc\ sin} possuem a mesma
saída.

Notem que nem tudo que foi apresentado faz sentido no momento, mas já dá
para entender o uso de uma função como sin. Vejamos agora a raiz
quadrada:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc}\NormalTok{ sqrt}
\end{Highlighting}
\end{Shaded}

Nela vemos que é possível calcular a raiz como em:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FloatTok{4.0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

Mas, observamos também na documentação a função \texttt{big()}, que tem
a seguinte ajuda:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc} \DataTypeTok{BigInt}
\end{Highlighting}
\end{Shaded}

A função \texttt{big()} em Julia é usada para criar números inteiros
grandes, representados pelo tipo BigInt. Essa função é especialmente
útil quando você precisa lidar com números muito grandes que excedem o
limite dos tipos inteiros padrão, como Int64 ou Int32.

Com números BigInt, já não há problemas de estouro, como podemos ver
abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{big}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{\^{}} \FloatTok{1002}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504
\end{verbatim}

Podemos ainda carregar funções de outros arquivos em nosso arquivo Julia
ou no próprio terminal, para isso basta utilizar o comando
\texttt{include("caminho/do/arquivo.jl")}, Julia lê o arquivo
especificado e executa todo o seu conteúdo no contexto atual. Isso
significa que todas as funções, variáveis e definições no arquivo
tornam-se disponíveis no ambiente onde \texttt{include} foi chamado.

Como por exemplo no primeiro caso tenho um arquivo chamado
\texttt{funcoes.jl} que possui a função soma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{ola}\NormalTok{(nome)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Olá"}\NormalTok{, nome)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ola (generic function with 1 method)
\end{verbatim}

Podemos incluir essa função em um segundo arquivo utilizando o
\texttt{include("funcoes.jl")}, e utilizar a função definida no arquivo
\texttt{funcoes.jl}

\begin{verbatim}
    include("funcoes.jl")
    println(ola("Alfredo"))  
\end{verbatim}

Cuja saída deverá ser \texttt{Olá\ Alfredo}.

\section{Variáveis e seus tipos}\label{variuxe1veis-e-seus-tipos}

Em Julia também temos o conceito de variáveis, que servem para armazenar
os diferentes conteúdos de dados possíveis.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{7}
\FloatTok{2} \OperatorTok{+}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9
\end{verbatim}

\subsection{Tipagem dinâmica}\label{tipagem-dinuxe2mica}

É importante notar que as variáveis em Julia podem receber novos valores
e o tipo da variável depende do que foi atribuído por último.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{3}
\FunctionTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1}
\FunctionTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

Neste próximo exemplo, a variável b é inicializada com um valor de tipo
inteiro, contudo, após a operação de multiplicação, seu valor é do tipo
ponto flutuante:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b }\OperatorTok{=} \FloatTok{3}
\NormalTok{b }\OperatorTok{=}\NormalTok{ b }\OperatorTok{*} \FloatTok{0.5}
\FunctionTok{typeof}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

A tipagem dinâmica apresenta diversas vantagens, entre elas a
flexibilidade, pois é possível reutilizar variáveis para armazenar
diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois
não é necessário especificar o tipo de cada variável, o que melhora a
legibilidade do código.

Aproveitando o momento, podemos ver que há vários tipos primitivos em
Julia, sendo os principais:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\StringTok{"Bom dia"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
String
\end{verbatim}

Falando em Strings, elas são definidas por conjuntos de caracteres entre
aspas como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=} \StringTok{"Olha que legal"}
\NormalTok{s2 }\OperatorTok{=} \StringTok{"Outra String"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Outra String"
\end{verbatim}

Dá também para fazer operações com strings como concatenação:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=} \StringTok{"Tenha um"}
\NormalTok{s2 }\OperatorTok{=} \StringTok{" Bom dia"}
\NormalTok{s3 }\OperatorTok{=}\NormalTok{ s1 }\OperatorTok{*}\NormalTok{ s2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Tenha um Bom dia"
\end{verbatim}

Ou potência:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=} \StringTok{"Nao vou mais fazer coisas que possam desagradar os meus colegas "}
\NormalTok{s }\OperatorTok{\^{}} \FloatTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa" ⋯ 98 bytes ⋯ "s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas "
\end{verbatim}

Ainda sobre variáveis, há umas regras com relação aos seus nomes, tem
que começar com uma letra (ou com \texttt{\_}), pode ter dígitos e não
pode ser uma palavra reservada. É bom notar que Julia por ser uma
linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o
Δ (\texttt{\textbackslash{}Delta}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Δ }\OperatorTok{=} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Mas, a linguagem vai bem além com caracteres de animais e símbolos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{🐱 }\OperatorTok{=} \FloatTok{5} \CommentTok{\# \textbackslash{}:cat: \textless{}tab\textgreater{}}
\NormalTok{🐶 }\OperatorTok{=} \FloatTok{3} \CommentTok{\# \textbackslash{}:dog: \textless{}tab\textgreater{}}
\NormalTok{🏠 }\OperatorTok{=} \FloatTok{20} \CommentTok{\# \textbackslash{}:house: \textless{}tab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
20
\end{verbatim}

Isso não adiciona nada do lado de algoritmos, mas é possível ter
variáveis bem bonitinhas. A lista de figuras pode ser encontrada
\href{://docs.julialang.org/en/v1/manual/unicode-input/}{aqui}.

\section{Saída de dados}\label{sauxedda-de-dados}

Para fazer saídas usam-se dois comandos, \texttt{print()} e o
\texttt{println()}, sendo que o primeiro não pula linha e o segundo
pula.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\StringTok{"Hello "}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"World!"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"Ola, mundo!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hello World!
Ola, mundo!
\end{verbatim}

Para evitar que se digitem muitos caracteres, por vezes podemos usar
``açucares sintáticos''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{1}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \FloatTok{1}
\NormalTok{x }\OperatorTok{+=} \FloatTok{1}  \CommentTok{\# forma equivalente a acima, o mesmo vale para os operadores *, {-} e /}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Acima, vimos a forma de se inserir comentários em Julia (sim esses serão
ignorados pelo computador).

Exercício: Faça o passo a passo para encontrar as raízes da equação de
segundo grau \(x^2 - 5 x + 6\), usando as váriaveis \texttt{a},
\texttt{b}, \texttt{c}, \texttt{\textbackslash{}Delta}, \texttt{x1} e
\texttt{x2}. Após isso, compare com a solução a seguir:

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# Definição dos coeficientes}
\NormalTok{a }\OperatorTok{=} \FloatTok{1}
\NormalTok{b }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{5}
\NormalTok{c }\OperatorTok{=} \FloatTok{6}

\CommentTok{\# Cálculo do discriminante}
\NormalTok{delta }\OperatorTok{=}\NormalTok{ b}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{{-}} \FloatTok{4} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ c}

\CommentTok{\# Cálculo das raízes}
\ControlFlowTok{if}\NormalTok{ delta }\OperatorTok{\textgreater{}=} \FloatTok{0}
\NormalTok{    x1 }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\NormalTok{b }\OperatorTok{+} \FunctionTok{sqrt}\NormalTok{(delta)) }\OperatorTok{/}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ a)}
\NormalTok{    x2 }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\NormalTok{b }\OperatorTok{{-}} \FunctionTok{sqrt}\NormalTok{(delta)) }\OperatorTok{/}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ a)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"As raízes são: x1 = }\SpecialCharTok{$}\NormalTok{x1}\StringTok{ e x2 = }\SpecialCharTok{$}\NormalTok{x2}\StringTok{"}\NormalTok{)}
\ControlFlowTok{else}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A equação não possui raízes reais."}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
As raízes são: x1 = 3.0 e x2 = 2.0
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Introdução às
Funções}\label{introduuxe7uxe3o-uxe0s-funuxe7uxf5es}

Objetivo: Começar a entender como funcionam as funções em uma linguagem
de programação

\section{O uso de funções é uma abstração
natural}\label{o-uso-de-funuxe7uxf5es-uxe9-uma-abstrauxe7uxe3o-natural}

Na aula passada já vimos umas funções e isso foi bem natural, foram
elas:

\begin{itemize}
\item
  typeof() - Dado um parâmetro devolve o seu tipo. Variáveis estão
  associadas a tipos;
\item
  div() - Dados dois parâmetros devolve a divisão inteira do primeiro
  pelo segundo;
\item
  print() e println() - Dados diversos parâmetros os imprime, sem
  devolver nada.
\end{itemize}

Inclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para
saber o que fazem as funções. Para isso, se usa o ? antes da função:

\begin{verbatim}
?typeof()
?div()
?print()
\end{verbatim}

Ao fazer isso, inclusive descobrimos que o div() pode ser usado também
como \div.

Uma outra função bem útil é a que permite transformar um tipo de valor
em outro.

\begin{verbatim}
parse(Float64, "32")
\end{verbatim}

Para conversão de valores em ponto flutuante para inteiros, temos a
função trunc.

\begin{verbatim}
trunc(Int64, 2.25)
\end{verbatim}

De forma inversa temos o float.

\begin{verbatim}
float(2)
\end{verbatim}

Finalmente, podemos transformar um valor em uma string, como em:

\begin{verbatim}
string(3)
\end{verbatim}

ou

\begin{verbatim}
string(3.57)
\end{verbatim}

Também tem muitas funções matemáticas prontas como

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2714}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Função
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descrição
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{sin(x)} & Calcula o seno de ( x ) em radianos \\
\texttt{cos(x)} & Calcula o cosseno de ( x ) em radianos \\
\texttt{tan(x)} & Calcula a tangente de ( x ) em radianos \\
\texttt{deg2rad(x)} & Converte ( x ) de graus em radianos \\
\texttt{rad2deg(x)} & Converte ( x ) de radianos em graus \\
\texttt{log(x)} & Calcula o logaritmo natural de ( x ) \\
\texttt{log(b,\ x)} & Calcula o logaritmo de ( x ) na base ( b ) \\
\texttt{log2(x)} & Calcula o logaritmo de ( x ) na base 2 \\
\texttt{log10(x)} & Calcula o logaritmo de ( x ) na base 10 \\
\texttt{exp(x)} & Calcula o expoente da base natural de ( x ) \\
\texttt{abs(x)} & Calcula o módulo de ( x ) \\
\texttt{sqrt(x)} & Calcula a raiz quadrada de ( x ) \\
\texttt{cbrt(x)} & Calcula a raiz cúbica de ( x ) \\
\texttt{factorial(x)} & Calcula o fatorial de ( x ) \\
\end{longtable}

A melhor forma de se acostumar a usar as funções é fazendo contas e
verificando os resultados. Uma dica importante é que para funções mais
complexas, pode ser que já existam funções prontas em Julia. Para isso
uma busca com as palavras chave. Um exemplo a seguir para procurar a
função para o cálculo de seno hiperbólico: ``julia lang hiperbolic
sin''. A busca pelo termo em inglês é uma boa dica para buscas em geral.

Em julia também é possível criar funções conforme as suas necessidades,
como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{mensagemDeBomDia}\NormalTok{()}
   \FunctionTok{println}\NormalTok{(}\StringTok{"Tenha um bom dia!"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
mensagemDeBomDia (generic function with 1 method)
\end{verbatim}

Para usar uma função, basta chamá-la:

\begin{verbatim}
MensagemDeBomDia()
\end{verbatim}

Funções, podem receber um ou mais parâmetros:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(a)}
   \FunctionTok{println}\NormalTok{(}\StringTok{" Vou imprimir "}\NormalTok{, a)}
\KeywordTok{end}
\FunctionTok{imprime}\NormalTok{(}\FloatTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Vou imprimir 42
\end{verbatim}

Também é possível que uma função chame outra função como em:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeduasvezes}\NormalTok{(a)}
   \FunctionTok{imprime}\NormalTok{(a)}
   \FunctionTok{imprime}\NormalTok{(a)}
\KeywordTok{end}
\FunctionTok{imprimeduasvezes}\NormalTok{(}\FloatTok{13}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Vou imprimir 13
 Vou imprimir 13
\end{verbatim}

Mais ainda, também é possível diferenciar funções por meio da quantidade
de parâmetros.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{recebe}\NormalTok{(a)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Recebi um parametro: "}\NormalTok{, a)}
\KeywordTok{end}
\KeywordTok{function} \FunctionTok{recebe}\NormalTok{(a, b)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Recebi dois parametros: "}\NormalTok{, a, }\StringTok{" "}\NormalTok{, b)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
recebe (generic function with 2 methods)
\end{verbatim}

Conforme a chamada, a função chamada será diferente:

\begin{verbatim}
recebe(1)
recebe(1, 2)
\end{verbatim}

Também dá para chamar funções com variáveis e com operações, como em:

\begin{verbatim}
a = 10
recebe(a)
recebe(a, a + 1)
\end{verbatim}

As funções que vimos até agora imprimem mensagens, mas não devolvem
nada. O typeof() delas é nothing, ou seja, algo que não pode ser
atribuído.

Mas, também é possível fazer funções que devolvem valores, como:

\begin{verbatim}
function soma1(a)
  return a + 1
end
\end{verbatim}

Nesse caso, se for passado um parâmetro numérico, a função devolverá o
valor incrementado (adicionado de 1).

Claro que isso pode ser usado com fórmulas mais complicadas como:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{hipotenusa}\NormalTok{(a, b)}
\NormalTok{  hip }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ b}
  \ControlFlowTok{return}\NormalTok{ hip}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
hipotenusa (generic function with 1 method)
\end{verbatim}

Exercício: Faça uma função para encontrar o \Delta de uma equação de
segundo grau

\bookmarksetup{startatroot}

\chapter{Comparações, o comando if e
recursão}\label{comparauxe7uxf5es-o-comando-if-e-recursuxe3o}

Antes de falar em desvio (if), vamos ver um novo tipo de variável que
foi introduzido de forma natural. O tipo booleando, ou seja uma variável
que pode valer true (verdadeiro) ou false (falso). O seu uso está
intimamente ligado ao if.

Observem os seguintes exemplos:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2} \OperatorTok{+} \FloatTok{2} \OperatorTok{==} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{!=} \FloatTok{8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{\textless{}} \FloatTok{24}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{42} \OperatorTok{\textless{}=} \FloatTok{44}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{42} \OperatorTok{\textless{}} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Vale chamar a atenção, como em linguagens de programação o = é usado
para atribuições, para comparações se usa o \texttt{==}. Da mesma forma
o != é usado como diferente. Esses operadores, em conjunto com o
\texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}} e
\texttt{\textgreater{}=} nos permitem comparar valores.

Sobre as variáveis booleanas vale também observar o seu tipo. Uma
explicação mais aprofundada sobre como essas variáveis funcionam será
fornecida quando abordarmos os operadores condicionais:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{2} \OperatorTok{==} \FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Bool
\end{verbatim}

Finalmente, também podemos negar variáveis booleanas para inverter o seu
valor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{!}\ConstantTok{true}
\NormalTok{!}\ConstantTok{false}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

Nessa aula, vamos aprender um novo comando. O desvio condicional,
através dele é possível alterar o fluxo de execução de um programa. Até
o momento não tínhamos comentado isso explicitamente, mas a ordem de
execução de instruções segue a ordem em que elas estão. Vejamos o
exemplo abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Oi"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"um"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"dois"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Oi
um
dois
\end{verbatim}

A ordem de impressão será Oi, um e dois.

Da mesma forma não temos problema ao executar o código abaixo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{denominador }\OperatorTok{=} \FloatTok{0}
\NormalTok{denominador }\OperatorTok{+=} \FloatTok{2}
\FloatTok{30} \OperatorTok{/}\NormalTok{ denominador}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
15.0
\end{verbatim}

Apesar da variável denominador começar inicialmente com 0, antes de se
fazer a divisão, ela estará valendo 2.

Como é de se esperar nem sempre queremos que essa ordem seja respeitada.
Observe o seguinte exemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pandemia }\OperatorTok{=} \ConstantTok{true}
\FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
   \FunctionTok{println}\NormalTok{(}\StringTok{"Só vou sair de casa se for essencial"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
Só vou sair de casa se for essencial
\end{verbatim}

O exemplo acima é claro, se uma condição for verdadeira, o código que
está no escopo do if (isso é entre a condição e o end) será executado.

Um outro exemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{denominador }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{if}\NormalTok{ denominador }\OperatorTok{!=} \FloatTok{0}
   \FunctionTok{println}\NormalTok{(}\StringTok{"sei fazer a divisão se não for por zero"}\NormalTok{)}
   \FunctionTok{println}\NormalTok{(}\StringTok{"o resultado da divisão de 30 por "}\NormalTok{, denominador, }\StringTok{" é igual a "}\NormalTok{, }\FloatTok{30}\OperatorTok{/}\NormalTok{denominador)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sei fazer a divisão se não for por zero
o resultado da divisão de 30 por 1 é igual a 30.0
\end{verbatim}

Situações muito comuns em computação devem ser favorecidas pela
linguagem, nesse caso do if, é muito comum termos duas ou mais
situações. Nesse sentido em Julia podemos também ter alternativas como
abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ pandemia }\OperatorTok{=} \ConstantTok{true}
 \FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
 \ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Só vou sair de casa se for essencial"}\NormalTok{)}
 \ControlFlowTok{else}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Balada liberada!!"}\NormalTok{)}
 \ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
Só vou sair de casa se for essencial
\end{verbatim}

No caso de termos mais de uma altenativa, não basta termos só uma
condição, nesse caso temos que usar elseif.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pandemia }\OperatorTok{=} \ConstantTok{true}
\NormalTok{tenhoqueestudar }\OperatorTok{=} \ConstantTok{true}
\FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Só vou sair de casa se for essencial"}\NormalTok{)}
\ControlFlowTok{elseif}\NormalTok{ tenhoqueestudar }\OperatorTok{==} \ConstantTok{true}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Melhor ficar em casa"}\NormalTok{)}
\ControlFlowTok{else}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Balada liberada"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
Só vou sair de casa se for essencial
\end{verbatim}

Conhecendo o if, agora, escreva uma função que recebe os coeficientes,
a, b e c de uma equação de segundo grau e imprime as suas raízes reais.

Sim, a forma de se aprender a programar é programando.

Vamos agora a parte mais importante do curso, lembrando que até o
momento aprendemos: - valores - varíaveis e alguns dos seus tipos -
alguma funções já prontas como div(), typeof(), parse(), string(),
println(), sin(), etc - como fazer as nossas funções com a palavra
reservada function e que termina por end - lembrando que a função pode
ou não devolver algo através do return - lembrando também que uma função
pode chamar outra função - como mudar o fluxo de execução normal com o
if, elseif

\section{Agora sim: Funções que se
chamam}\label{agora-sim-funuxe7uxf5es-que-se-chamam}

Agora podemos, ir ao tópico principal da aula.

Observe a seguinte função imprime().

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{()}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Mensagem positiva"}\NormalTok{)}
    \FunctionTok{imprime}\NormalTok{()}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 1 method)
\end{verbatim}

Ao ser chamada, o que acontece? O computador fará chamadas seguidas a
função, imprimindo a mensagem, até o momento que ocorra uma limitação de
memória. Logo, fazer chamadas onde uma função se chama, sem controle não
é uma boa ideia.

Por outro lado, podemos pensar em uma forma de chamada controlada, onde
a própria função decide o momento de parar de se chamar. Para isso,
vamos pegar uma função matemática bem conhecida, o fatorial.

Sabemos que 5! = 5.4.3.2.1. Mais, ainda dado um número n, sabemos que n!
= n.(n - 1)! Continuando, temos que (n - 1)! = (n - 1).(n - 2)! e assim
por diante. Para reproduzir isso no computador precisamos saber quando
parar. Para isso, podemos usar que o fatorial de zero é 1, ou 0! = 1.
Logo já temos a primeira parte da função:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n)}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0}
   \ControlFlowTok{return} \FloatTok{1}
 \ControlFlowTok{else}
   \CommentTok{\# o que vamos colocar aqui?}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

No código acima, temos o critério de parada, ou seja quando n for igual
a zero, a resposta será 1. Mas, e se n não for zero. Nesse caso, temos
que seguir a fórmula da recursão ou seja n.(n - 1)!. Como (n - 1)! pode
ser escrito como fatorial(n - 1). Ficamos com a expressão n * fatorial(n
- 1).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n)}
 \CommentTok{\# Critério de parada: quando n é igual a 0, a recursão termina}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0}
   \ControlFlowTok{return} \FloatTok{1}
 \ControlFlowTok{else}
   \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\CommentTok{\# Chamada recursiva}
 \ControlFlowTok{end}
\KeywordTok{end}
\FunctionTok{fatorial}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
120
\end{verbatim}

Vamos a um segundo exemplo, a contagem regressiva. Mais uma vez, quando
se chega a zero, podemos considerar que a contagem terminou. Além disso,
a cada número, o próximo passo é o número menos 1.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contagem}\NormalTok{(n)}
   \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \FloatTok{0}
       \FunctionTok{println}\NormalTok{(}\StringTok{"Bum!"}\NormalTok{)}
   \ControlFlowTok{else}
       \FunctionTok{print}\NormalTok{(n, }\StringTok{" "}\NormalTok{)}
       \FunctionTok{contagem}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
   \ControlFlowTok{end}
\KeywordTok{end}
\FunctionTok{contagem}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5 4 3 2 1 0 Bum!
\end{verbatim}

Essa estrutura é bem poderosa, pois permite que operações sejam
executadas um número controlado de vezes. Voltando ao countdown, imagine
que ao invés de imprimir uma mensagem quiséssemos fazer uma conta com o
que será devolvido.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{soma}\NormalTok{(n)}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{0}
   \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{+} \FunctionTok{soma}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
 \ControlFlowTok{else}
   \ControlFlowTok{return} \FloatTok{0}
 \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{soma}\NormalTok{(}\FloatTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
66
\end{verbatim}

Essa estrutura é bastante poderosa e pode ser usada para o cálculo de
produto, nesse caso, a mudança é bem pequena.

Da mesma forma segue um exemplo para o cálculo dos n primeiros elementos
da soma hârmonica.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaharmonica}\NormalTok{(atual, n)}
 \CommentTok{\# Caso base: se \textquotesingle{}atual\textquotesingle{} é maior ou igual a \textquotesingle{}n\textquotesingle{}}
 \ControlFlowTok{if}\NormalTok{ atual }\OperatorTok{\textgreater{}=}\NormalTok{ n}
   \CommentTok{\# Retorna o recíproco de \textquotesingle{}atual\textquotesingle{} (último termo da soma)}
   \ControlFlowTok{return} \FloatTok{1.0} \OperatorTok{/}\NormalTok{ atual}
 \ControlFlowTok{else}
   \CommentTok{\# Caso recursivo: soma o recíproco de \textquotesingle{}atual\textquotesingle{} e chama a função para o próximo número}
   \ControlFlowTok{return} \FloatTok{1.0} \OperatorTok{/}\NormalTok{ atual }\OperatorTok{+} \FunctionTok{somaharmonica}\NormalTok{(atual }\OperatorTok{+} \FloatTok{1}\NormalTok{, n)}
 \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{somaharmonica}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.9289682539682538
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{}\label{section}

Nessa aula, vamos ver algoritmos um pouco mais elaborados. Mas, sabendo
que vamos usar algo com um maior grau de sofisticação, que tal pensar em
testes?

De uma forma geral, para verificar o funcionamento de um programa,
podemos escrever testes que verificam o funcionamento em algumas
situações específicas.

Dado que o primeiro problema que queremos resolver é um algoritmo que
encontra o n-ésimo número de Fibonacci. Por que não começar com testes?

Uma forma de se fazr testes, e de forma manual, mas isso não é
reprodutível. A melhor maneira de se fazer testes, é de forma
automatizada, ou seja criar código que teste código. Isso pode parecer
complicado, mas vamos ver abaixo que não é.

Em uma busca rápida, podemos ver que a sequência de Fibonacci é definida
da seguinte forma, os dois primeiros elementos \(F_1\) e \(F_2\) valem
1, em seguida temos a fórmula \(F_n = F_{n-1} +  F_{n-2}\). Mas, antes
de pensar em resolver o problema vamos pensar em como testar.

Já sabemos os primeiros valores, além disso, através de uma busca
rápida, podemos descobrir alguns valores da sequência como \(F_5 =  5\)
e \(F_{12}  =
144\). Supondo que a função para o cálculo do n-ésimo número de
Fibonacci chamará fibo(). Podemos escrever o seguinte trecho de código:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testafibo\_versao1}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 1"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 2"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{==} \FloatTok{5}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 5"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{12}\NormalTok{) }\OperatorTok{==} \FloatTok{144}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 12"}\NormalTok{)}
  \ControlFlowTok{end}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testafibo_versao1 (generic function with 1 method)
\end{verbatim}

A função de testes acima verifica se a função fibo() devolve o resultado
correto para três casos. Mas, ela tem um defeito, ela imprime mensagens
demais, o que pode ser ruim. Considerando isso, vamos ver o primeiro
fundamento importante com relação a testes automatizados.

\emph{Se o teste passou, ele deve indicar apenas que deu certo!}

Levando em conta o que foi escrito acima, podemos mudar o nosso teste
para:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testafibo}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Não deu certo para 1"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Não deu certo para 2"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Não eu certo para 5"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{12}\NormalTok{) }\OperatorTok{!=} \FloatTok{144}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Não deu certo para 12"}\NormalTok{)}
  \ControlFlowTok{end}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testafibo (generic function with 1 method)
\end{verbatim}

Agora de posse da nossa função de testes, podemos pensar em escrever a
nossa função de Fibonacci. Vamos ao caso fácil de n for menor que 2, a
resposta é 1. Como vemos abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \CommentTok{\# ainda não sabemos o que colocar aqui...}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fibo (generic function with 1 method)
\end{verbatim}

Mas, a resposta está na própria definição da função, ou seja:
\(F_n = F_{n-1} +  F_{n-2}\). Se o \(n\) for maior do que 2, temos que
fazer a soma dos valores de Fibonacci de \(n-1\) e de \(n-2\). Ou seja:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\OperatorTok{+} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{2}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

É interessante notar que apesar de ser um dos exemplos clássicos de uso
de recursão, o algoritmo acima é extremamente ineficiente. A razão é
simples, cada vez que é feita a chamada, toda os valores de Fibonacci
são recalculados para os valores de \(n\) e \(n-1\).

Como Julia é uma linguagem moderna podemos usar o conceito de
Memoização, que evita calcular o que já foi calculado. O Memoize tem que
ser instalado no Julia com os comandos \texttt{import\ Pkg} e
\texttt{Pkg.add("Memoize")}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Memoize}
\PreprocessorTok{@memoize} \KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\OperatorTok{+} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{2}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

As diferenças de tempo das duas versões podem ser verificada com o
comando @time. Da seguinte forma:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@time} \FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  0.000003 seconds
\end{verbatim}

\begin{verbatim}
55
\end{verbatim}

Esse tipo de comando, que começa com @ é conhecido como anotação, e tem
o poder de mudar o comportamente de partes do código.

Vamos ao segundo algoritmo da aula, o MDC (Máximo Divisor Comum). A
ideia é usar o algoritmo de Euclides.

Basicamente ele diz que o MDC de dois números a e b, é igual ao MDC de b
e r, onde \(r=a\% b\). Quando esse resto for zero, chegamos a solução,
que é b.

Vamos começar com os testes para alguns valores bem conhecidos. Por
sinal começar pelos testes antes de escrever o código é uma boa prática
de programação conhecida por TDD (Test Driven Design).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testaMDC}\NormalTok{()}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{3298}\NormalTok{, }\FloatTok{2031}\NormalTok{)}\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 3298 e 2031"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{120}\NormalTok{, }\FloatTok{36}\NormalTok{)}\OperatorTok{!=} \FloatTok{12}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 120 e 36"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{36}\NormalTok{, }\FloatTok{120}\NormalTok{)}\OperatorTok{!=} \FloatTok{12}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 36 e 120"}\NormalTok{)}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Acabaram os testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaMDC (generic function with 1 method)
\end{verbatim}

Vamos pensar na função agora. Dessa vez, se o resto for 0, temos que
devolver o segundo termo. Caso contrário temos que continuar com a regra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{MDC}\NormalTok{(a, b)}
\NormalTok{    r }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}
    \ControlFlowTok{if}\NormalTok{ r }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return}\NormalTok{ b}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{MDC}\NormalTok{(b, r)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{testaMDC}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Acabaram os testes
\end{verbatim}

Até agora usamos o modo interativo do Julia para fazer os nosso códigos.
Mas, existe oura forma bem mais reutilizável, ou seja escrever o texto
em arqivos. Isso é relativamente simples, basta usar um editor de texto
(puro) da sua preferência, como o notepad, nano, juno, atom, vscode ou
outro e salvar um arquivo com a extensão .jl.

Mas, para que algo seja executado é importante colocar uma chamada ao
final. Veja abaixo um possível arquivo mdc.jl.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testeMDC}\NormalTok{()}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{70}\NormalTok{, }\FloatTok{5}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 70 e 5"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{13}\NormalTok{, }\FloatTok{7}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 13 e 7"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{127}\NormalTok{, }\FloatTok{15}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 127 e 15"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{20}\NormalTok{, }\FloatTok{15}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 20 e 15"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{42}\NormalTok{, }\FloatTok{3}\NormalTok{) }\OperatorTok{!=} \FloatTok{3}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 42 e 3"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{42}\NormalTok{, }\FloatTok{8}\NormalTok{) }\OperatorTok{!=} \FloatTok{2}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Não funcionou para 42 e 8"}\NormalTok{)}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{mdc}\NormalTok{(a, b)}
\NormalTok{    r }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}
    \ControlFlowTok{if}\NormalTok{ r }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return}\NormalTok{ b}
    \ControlFlowTok{else}
        \FunctionTok{mdc}\NormalTok{(b, r)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{testeMDC}\NormalTok{()}
\FunctionTok{println}\NormalTok{(}\StringTok{"O mdc entre 1227 e 321 é "}\NormalTok{, }\FunctionTok{mdc}\NormalTok{(}\FloatTok{1227}\NormalTok{, }\FloatTok{321}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Final dos testes
O mdc entre 1227 e 321 é 3
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Testes automatizados e um pouco mais de
código}\label{testes-automatizados-e-um-pouco-mais-de-cuxf3digo}

Vamos começar o capítulo vendo uma forma mais simples de se rodar
testes. Nos testes que vimos até agora sempre havia o teste de uma
condição booleana associado a uma mensagem de erro quando não
funcionasse. Mas, observando que a mensagem de erro geralmente está
ligada à condição, por vezes a condição pode ser auto-explicativa.

Logo, uma forma elegante de expressar as condições pode ser útil na
escrita dos testes. Para isso, vamos usar o módulo de testes. Em
linguagens modernas, várias das situações repetitivas que enfrentamos
podem ser evitadas usando alguma técnica mais moderna.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}  
\PreprocessorTok{@testset} \StringTok{"Modelo de testes"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FloatTok{2} \OperatorTok{==} \FloatTok{1} \OperatorTok{+} \FloatTok{1}
    \PreprocessorTok{@test} \ConstantTok{true}
    \PreprocessorTok{@test}\NormalTok{ !}\ConstantTok{false}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:    | Pass  Total  Time
Modelo de testes |    3      3  0.0s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Modelo de testes", Any[], 3, false, false, true, 1.729115739073162e9, 1.729115739095434e9, false, "/home/lucas/Área de trabalho/livro-alfredo/aulas/07.qmd")
\end{verbatim}

No trecho acima primeiro indicamos que queremos fazer testes. Em seguida
usamos o \emph{test} que espera uma condição ou valor booleano.
Finalmente todos os testes são reunidos em um \emph{testset}.

Claro que o teste dá infomações relevantes quando falha:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\PreprocessorTok{@test} \FloatTok{2} \OperatorTok{+} \FloatTok{2} \OperatorTok{!=} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Failed at REPL[2]:1
  Expression: 2 + 2 != 4
   Evaluated: 4 != 4
\end{verbatim}

Agora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a
soma dos dígitos de um número inteiro. Ou seja, pensar em um número
dígito à dígito. Vamos aos testes primeiro:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\PreprocessorTok{@testset} \StringTok{"Teste da Soma de Dígitos"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{0}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{100}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{123}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{321}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{99}\NormalTok{) }\OperatorTok{==} \FloatTok{18}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Vamos agora tentar pensar em como ``descascar'' um número, dado o número
123, uma forma seria pegar o resto por 10 (ou seja 3) e depois dividir
por 10 (ou seja 12), e assim por diante. Ou seja.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaDig}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=}\FloatTok{0} \ControlFlowTok{return} \FloatTok{0}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{\%} \FloatTok{10} \OperatorTok{+} \FunctionTok{somaDig}\NormalTok{(n }\OperatorTok{÷} \FloatTok{10}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\FunctionTok{somaDig}\NormalTok{(}\FloatTok{1234}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

Vamos agora a um outro problema clássico, a verificação se um número é
ou não é primo. Na prática para fazer isso, temos a definição, um número
\(n\) é primo apenas se for divisível apenas por 1 e por ele mesmo. Ou
seja, nenhum número entre 2 e \(n - 1\) pode ser divisor de um número
primo.

A forma de se fazer isso é relativamente simples. Vamos pensar em uma
função que tenta dividir um número recursivamente, se conseguir devolve
falso, se não conseguir devolve verdadeiro.

Vamos aos código:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{divide}\NormalTok{(n, i)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{elseif}\NormalTok{ i }\OperatorTok{==}\NormalTok{ n }\OperatorTok{{-}} \FloatTok{1}
        \ControlFlowTok{return} \ConstantTok{true}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{divide}\NormalTok{(n, i }\OperatorTok{+} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
divide (generic function with 1 method)
\end{verbatim}

Que pode ser chamada por:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{éPrimo}\NormalTok{(n)}
    \ControlFlowTok{return} \FunctionTok{divide}\NormalTok{(n, }\FloatTok{2}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
éPrimo (generic function with 1 method)
\end{verbatim}

Mais um exemplo, o método de Newton para o cálculo de raiz quadrada.
Para achar a raiz de \(x\), a partir de um chute inicial (por exemplos
\(y= x /2\)), chegamos a um novo chute que é a média de \(y\) e \(x/y\).

Mas, sim, vamos começar com os testes. Como estamos usando números do
tipo \emph{double} é bom sempre ter uma tolerância, por isso vamos usar
uma comparação aproximada. Também poderiamos ter usado a função
\emph{isapprox} da linguagem Julia.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{quaseIgual}\NormalTok{(a, b)}
    \ControlFlowTok{if} \FunctionTok{abs}\NormalTok{(a }\OperatorTok{{-}}\NormalTok{ b) }\OperatorTok{\textless{}=} \FloatTok{1e{-}10}
        \ControlFlowTok{return} \ConstantTok{true}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\KeywordTok{end}


\PreprocessorTok{@testset} \StringTok{"Teste da raiz pelo método de Newton"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{3.0}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{3.0} \OperatorTok{*} \FloatTok{3.0}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{33.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{33.7} \OperatorTok{*} \FloatTok{33.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{223.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{223.7} \OperatorTok{*} \FloatTok{223.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{0.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{0.7} \OperatorTok{*} \FloatTok{0.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{1.0} \OperatorTok{*} \FloatTok{1.0}\NormalTok{))}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Note que como estamos comparando números em ponto flutuante, não usamos
a comparação exata.

A solução final é:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{newton}\NormalTok{(c, n)}
\NormalTok{    q }\OperatorTok{=}\NormalTok{ n }\OperatorTok{/}\NormalTok{ c}
    \ControlFlowTok{if} \FunctionTok{quaseIgual}\NormalTok{(q, c)}
        \ControlFlowTok{return}\NormalTok{ q}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{newton}\NormalTok{( (c }\OperatorTok{+}\NormalTok{ q) }\OperatorTok{/} \FloatTok{2.0}\NormalTok{, n)}
    \ControlFlowTok{end}
\KeywordTok{end}


\KeywordTok{function} \FunctionTok{raiz}\NormalTok{(n)}
\NormalTok{    a }\OperatorTok{=}  \FunctionTok{newton}\NormalTok{(n }\OperatorTok{/} \FloatTok{2.0}\NormalTok{, n)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"a raiz de "}\NormalTok{, n, }\StringTok{" é "}\NormalTok{, a)}
    \ControlFlowTok{return}\NormalTok{ a}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
raiz (generic function with 1 method)
\end{verbatim}

\section{Funções caóticas}\label{funuxe7uxf5es-cauxf3ticas}

Vamos brincar um pouco agora com funções caóticas :), isso é, funções,
que conforme o comportamento de uma constante \(k\), apresentam
resultados que podem convergir ou não. Isso é, a cada passo, quero saber
o valor do próximo ponto aplicando a função novamente, isso é:
\[x_1 = f(x_0), x_2 = f(x_1), \ldots, x_n  = f(x_{n - 1})\]

As funções caóticas desempenham um papel significativo em diversas áreas
da matemática e da física, com aplicações que vão desde a modelagem de
crescimento populacional até a previsão de padrões climáticos. Elas
também são fundamentais na análise de circuitos elétricos não lineares,
onde pequenas variações nas condições iniciais podem levar a resultados
drasticamente diferentes.

Para o nosso teste, a função \(f\) é extremamente simples:
\(x_{i + 1}=x_i * (1 -  x_i) * k\).

Implemente a função e imprima os 30 primeiros resultados. Comece com um
valor de \(x\) entre 0 e 1, como 0.2. Use constantes
\(k = 2.1, 2.5, 2.8\) e \(3.1\) o que ocorre com \(k = 3.7\)?

Entregue o código e um pequeno relatório sobre o que acontece.

\bookmarksetup{startatroot}

\chapter{Uma outra forma de se fazer
laços}\label{uma-outra-forma-de-se-fazer-lauxe7os}

Até o momento vimos que o computador é muito bom para fazer contas e
repetições. Fizemos isso até agora com funções recursivas. Mas, existe
um outro comando para isso, o while. A motivação é que enquanto alguma
condição for válida, o computador continua repetindo os comandos.

O formato básico é o seguinte:

\begin{verbatim}
while condição
  # execute obloco
end  
\end{verbatim}

Enquanto a condição continuar verdadeira, o computador vai seguir
repetindo o bloco que pode ser formado por várias intruções. Logo, para
que a repetição, ou laço, não seja repetido indefinidamente, é essencial
que algo ligado a condição seja atualizado no corpo do while.

Vejamos o exemplo simples da contagem regressiva:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \FloatTok{5}
\ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{0}
  \FunctionTok{println}\NormalTok{(n)}
\NormalTok{  n }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \FloatTok{1}
\ControlFlowTok{end}
\FunctionTok{println}\NormalTok{(}\StringTok{"Acabou"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
4
3
2
1
Acabou
\end{verbatim}

Mas, vamos ver abaixo um caso onde o uso de while deixa o código mais
Claro que com a recursão (onde é ruim fazer uma com vários parãmetros).
Veja a resolução da série de Taylor abaixo:

\begin{Shaded}
\begin{Highlighting}[]
 \KeywordTok{function} \FunctionTok{sinTaylor2}\NormalTok{(x)}
\NormalTok{   i }\OperatorTok{=} \FloatTok{1}
\NormalTok{   termo }\OperatorTok{=}\NormalTok{ x}
\NormalTok{   soma }\OperatorTok{=} \FloatTok{0.0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FloatTok{15}
\NormalTok{     soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ termo}
\NormalTok{     termo }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1} \OperatorTok{*}\NormalTok{ termo }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{/}\NormalTok{ ((}\FloatTok{2} \OperatorTok{*}\NormalTok{ i) }\OperatorTok{*}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}\NormalTok{))}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sinTaylor2 (generic function with 1 method)
\end{verbatim}

Nela são calculados os 15 primeiros termos.

Observem a versão recursiva:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sinTaylor}\NormalTok{(x)}
    \ControlFlowTok{return} \FunctionTok{sinTaylorRec}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{15}\NormalTok{, x, }\FloatTok{1}\NormalTok{, x)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sinTaylorRec}\NormalTok{(i, n, x, sinal, termo)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ i}
      \ControlFlowTok{return} \FloatTok{0.0}
    \ControlFlowTok{else}
      \ControlFlowTok{return}\NormalTok{ sinal }\OperatorTok{*}\NormalTok{ termo }\OperatorTok{+}
         \FunctionTok{sinTaylorRec}\NormalTok{(i }\OperatorTok{+} \FloatTok{1}\NormalTok{, n, x, }\OperatorTok{{-}}\FloatTok{1} \OperatorTok{*}\NormalTok{ sinal, termo }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{/}\NormalTok{ (}\FloatTok{2}\OperatorTok{*}\NormalTok{i }\OperatorTok{*}\NormalTok{ (}\FloatTok{2}\OperatorTok{*}\NormalTok{i}\OperatorTok{+}\FloatTok{1}\NormalTok{)))}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sinTaylorRec (generic function with 1 method)
\end{verbatim}

Podemos também fazer operações com os dígitos de um número inteiro, para
isso operações como o resto da divisão por 10 e a divisão inteira por 10
são bastante úteis. Abaixo temos as duas versões que fazem a soma dos
dígitos de um número inteiro.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{testaSD}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{123}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{321}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{0}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{1001}\NormalTok{) }\OperatorTok{==} \FloatTok{2}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{3279}\NormalTok{) }\OperatorTok{==} \FloatTok{21}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Fim dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sd}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \FloatTok{0}
     \ControlFlowTok{return} \FloatTok{0}
  \ControlFlowTok{else}
\NormalTok{     d }\OperatorTok{=}\NormalTok{ x }\OperatorTok{\%} \FloatTok{10}
     \ControlFlowTok{return}\NormalTok{ d }\OperatorTok{+} \FunctionTok{sd}\NormalTok{(}\FunctionTok{div}\NormalTok{(x, }\FloatTok{10}\NormalTok{))}
  \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sd1}\NormalTok{(x)}
\NormalTok{  soma }\OperatorTok{=} \FloatTok{0}
  \ControlFlowTok{while}\NormalTok{ x }\OperatorTok{!=} \FloatTok{0}
\NormalTok{   d }\OperatorTok{=}\NormalTok{ x }\OperatorTok{\%} \FloatTok{10}
\NormalTok{   soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ d}
\NormalTok{   x }\OperatorTok{=} \FunctionTok{div}\NormalTok{(x, }\FloatTok{10}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\FunctionTok{testaSD}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Fim dos testes
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Aula de exercícios}\label{aula-de-exercuxedcios}

\section{Revisitando o cálculo do fatorial, recursivo e
interativo}\label{revisitando-o-cuxe1lculo-do-fatorial-recursivo-e-interativo}

Agora que aprendemos a fazer também repetições com o comando while,
sempre é bom pensar em qual o comando mais adequado. Vejamos o exemplo
abaixo com duas versões da função para o cálculo do Fatorial.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial\_recursivo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{) }\CommentTok{\# Com o ::Int64 estamos definindo que o parâmetro da função deve ser um número inteiro}
    \CommentTok{\# Caso base do fatorial: 0! e 1! são iguais a 1}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0} \OperatorTok{||}\NormalTok{ n }\OperatorTok{==} \FloatTok{1}
        \ControlFlowTok{return} \FloatTok{1}
    \CommentTok{\# Chamada recursiva: n! = n * (n{-}1)!}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial\_recursivo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{fatorial\_iterativo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
    \CommentTok{\# Inicializa o resultado como 1 (já que o fatorial de 0 é 1)}
\NormalTok{    resultado }\OperatorTok{=} \FloatTok{1}

    \CommentTok{\# No loop estamos fazendo a multiplicação: n * (n{-}1) * ... * 2}
    \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{1}
        \CommentTok{\# Multiplica o resultado pelo valor atual de n}
\NormalTok{        resultado }\OperatorTok{*=}\NormalTok{ n}

        \CommentTok{\# Decrementa n em 1 para continuar o cálculo do fatorial}
\NormalTok{        n }\OperatorTok{{-}=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ resultado}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\FunctionTok{fatorial\_recursivo}\NormalTok{(}\FloatTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

No código acima temos uma novidade, nos parâmetros da função, o tipo
está sendo declarado expicitamente. No caso, estamos dizendo que o valor
n que a função vai receber é de um tipo específico. Ou seja um Inteiro
de 64 bits.

O estilo de código está um pouco diferente do que antes, pois foi
escrito por outra pessoa. A monitora. Vemos que ela tem o hábito de usar
nomes de variáveis maiores além do que usar contrações como += e *=.

\section{Aproximação da raiz
quadrada}\label{aproximauxe7uxe3o-da-raiz-quadrada}

Para o próximo exemplo, vamos ver o método de Newthon-Raphson para o
cálculo da raiz quadrada. É um método recursivo no qual o próximo valor
é baseado no valor anterior. Quanto mais chamadas forem feitas, mais
próximo do valor final vai se chegar.

Mais informações sobre o método podem ser encontradas em
\href{https://pt.wikipedia.org/wiki/M\%C3\%A9todo_de_Newton\%E2\%80\%93Raphson}{aqui}.
Mas para o momento temos que pensar na seguinte implementação. Para se
calcular a raiz, podemos usar a seguinte fórmula, a partir de um palpite
inicial r, para o valor da raiz de x.

\[ r_{n+1} = 0.5 * (r + x / r)\]

Como o código abaixo é mais complicado, foram usados comentários.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{aproxima\_raiz}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Float64}\NormalTok{, epsilon}\OperatorTok{::}\DataTypeTok{Float64}\NormalTok{)}\OperatorTok{::}\DataTypeTok{Float64}
    \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \FloatTok{0}
        \ControlFlowTok{return} \ConstantTok{nothing}
    \ControlFlowTok{end}

    \CommentTok{\# Chute inicial }
\NormalTok{    aproximacao }\OperatorTok{=}\NormalTok{ x}\OperatorTok{/}\FloatTok{2}
\NormalTok{    melhor\_aproximicao }\OperatorTok{=}\NormalTok{ aproximacao}

    \ControlFlowTok{while} \ConstantTok{true}
        \CommentTok{\# Fórmula para aproximação de raiz quadrada utilizando o método de Newthon{-}Raphson}
\NormalTok{        melhor\_aproximicao }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{*}\NormalTok{ (aproximacao }\OperatorTok{+}\NormalTok{ x}\OperatorTok{/}\NormalTok{aproximacao)}

        \CommentTok{\# Se a distância absoluta entre os dois pontos é menor do que epsilon, então podemos parar o método}
        \ControlFlowTok{if} \FunctionTok{abs}\NormalTok{(aproximacao }\OperatorTok{{-}}\NormalTok{ melhor\_aproximicao) }\OperatorTok{\textless{}=}\NormalTok{ epsilon}
            \ControlFlowTok{break}
        \ControlFlowTok{end}

        \CommentTok{\# Se a aproximação ainda não for boa o sufuciente, então atualizamos a aproximação para a próxima iteração}
\NormalTok{        aproximacao }\OperatorTok{=}\NormalTok{ melhor\_aproximicao}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ melhor\_aproximicao}

\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
aproxima_raiz (generic function with 1 method)
\end{verbatim}

Notem que foi introduzido um comando novo, o break, esse comando apenas
interrompe a execução do while. Ou seja, força a saída do laço.

\section{Verificar se um número é
primo}\label{verificar-se-um-nuxfamero-uxe9-primo}

No próximo exemplo, vamos verificar se um número é primo, ou seja, se os
seus únicos divisores são 1 e o próprio. A forma mais simples de se
fazer isso é procurando dividir o número por outros. Se algum dividir, o
número não é primo.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verifica\_primo}\NormalTok{(num }\OperatorTok{::}\DataTypeTok{ Int64}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ num }\OperatorTok{\textless{}=} \FloatTok{1}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\NormalTok{    i}\OperatorTok{=}\FloatTok{2}
    \CommentTok{\# pode ser melhorado com i\textless{}=num/2}
    \CommentTok{\# ou também com i\textless{}= sqrt(num): baseado no fato que um número composto deve ter um fator menor ou igual a raiz desse número}
    \ControlFlowTok{while}\NormalTok{ i}\OperatorTok{\textless{}}\NormalTok{num}
        \ControlFlowTok{if}\NormalTok{ num }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \FloatTok{0}
            \ControlFlowTok{return} \ConstantTok{false}
        \ControlFlowTok{end}
\NormalTok{        i}\OperatorTok{+=}\FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verifica_primo (generic function with 1 method)
\end{verbatim}

Assim, como o comando break é usado para interromper a execução de um
laço, o comando return, pode ser usado para terminar a execução de uma
função, a qualquer momento.

\section{Verificar se um número é
palíndromo}\label{verificar-se-um-nuxfamero-uxe9-paluxedndromo}

Um número palíndromo é um número que é simétrico. Ou seja, a leitura dos
dígitos da esquerda para a direita é igual a leitura dos dígitos na
ordem inversa. Por exemplo, o número 121 é palíndromo, assim como o 11 e
o 25677652. Os números de um dígito também são.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{e\_palindromo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
    \CommentTok{\#=}
\CommentTok{        Guarda os dígitos de n que ainda devem ser invertidos}
\CommentTok{        A variável auxiliar é necessária para que o valor de n não seja, perdido, e possamos usar ele posteriormente.}
\CommentTok{    =\#}
\NormalTok{    aux }\OperatorTok{=}\NormalTok{ n}
    \CommentTok{\# Guarda a inversão do número n }
\NormalTok{    n\_inv }\OperatorTok{=} \FloatTok{0}

    \CommentTok{\#=}
\CommentTok{        Continuamos o while enquanto ainda há números a serem invertidos,}
\CommentTok{        ou seja, enquanto aux for maior que 0.}
\CommentTok{    =\#}
    \ControlFlowTok{while}\NormalTok{ aux }\OperatorTok{\textgreater{}} \FloatTok{0} 
        \CommentTok{\# Coloca o último dígito de aux na variável que guarda a inversão}
\NormalTok{        resto }\OperatorTok{=}\NormalTok{ aux }\OperatorTok{\%} \FloatTok{10}
\NormalTok{        n\_inv}\OperatorTok{=}\NormalTok{ n\_inv }\OperatorTok{*} \FloatTok{10} \OperatorTok{+}\NormalTok{ resto}

        \CommentTok{\# Retira o último dígito de aux}
\NormalTok{        aux }\OperatorTok{=} \FunctionTok{div}\NormalTok{(aux,}\FloatTok{10}\NormalTok{)}
    \ControlFlowTok{end}

    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ n\_inv}
        \FunctionTok{println}\NormalTok{(}\StringTok{"O número }\SpecialCharTok{$}\NormalTok{n}\StringTok{ é palíndromo"}\NormalTok{)}
    \ControlFlowTok{else}
        \FunctionTok{println}\NormalTok{(}\StringTok{"O número }\SpecialCharTok{$}\NormalTok{n}\StringTok{ não é palíndromo"}\NormalTok{)}
    \ControlFlowTok{end} 
\KeywordTok{end}

\FunctionTok{e\_palindromo}\NormalTok{(}\FloatTok{2002}\NormalTok{)}
\FunctionTok{e\_palindromo}\NormalTok{(}\FloatTok{1234}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
O número 2002 é palíndromo
O número 1234 não é palíndromo
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Revisitando a aula passada}\label{revisitando-a-aula-passada}

Além de discutirmos o que vimos na aula passada. Nessa aula, vimos uma
nova solução para o problema de verificar de um número é palíndromo.

Para isso usamos uma técnica um pouco diferente, ou seja, ao invés de
inverter o número e compará-lo com o original. Verificamos se os seus
extremos são iguais.

Observe o número 234432, o primeiro passo seria verificar que nos
extremos, mais significativo e menos significativo, temos os números 2.
Em seguida, podemos continuar com a verificação para o número 3443. Se
em algum momento a verificação falhar o número não é palíndromo.

Seguem os testes e o código abaixo.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{testaPal}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{1}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{131}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{22}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{53877835}\NormalTok{)}
  \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{testaPal}\NormalTok{(}\FloatTok{123}\NormalTok{)}
  \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{testaPal}\NormalTok{(}\FloatTok{23452}\NormalTok{)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{testaPal}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
\CommentTok{\# o primeiro passo é encontrar um número com o mesmo número de dígitos de n}
\NormalTok{  pot10 }\OperatorTok{=} \FloatTok{1}
  \ControlFlowTok{while}\NormalTok{ pot10 }\OperatorTok{\textless{}}\NormalTok{ n}
\NormalTok{    pot10 }\OperatorTok{=}\NormalTok{ pot10 }\OperatorTok{*} \FloatTok{10}
  \ControlFlowTok{end}
\NormalTok{  pot10 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(pot10, }\FloatTok{10}\NormalTok{)}


  \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{9}
\NormalTok{    d1 }\OperatorTok{=}\NormalTok{ n }\OperatorTok{\%} \FloatTok{10}
\NormalTok{    d2 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(n, pot10)}
    \ControlFlowTok{if}\NormalTok{ d1 }\OperatorTok{!=}\NormalTok{ d2}
      \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{div}\NormalTok{(n }\OperatorTok{\%}\NormalTok{ pot10, }\FloatTok{10}\NormalTok{)}
\NormalTok{    pot10 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(pot10, }\FloatTok{100}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaPal (generic function with 2 methods)
\end{verbatim}

\section{Aleatoreidade}\label{aleatoreidade}

Em julia temos a função rand() que devolve um número em ponto flutuante
entre 0 e 1. Conforme os parâmetros, podemos ter outros tipos de número
como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rand}\NormalTok{(}\DataTypeTok{Int}\NormalTok{)  }\CommentTok{\# devolve um inteiro}
\FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{) }\CommentTok{\# devolve um número entre 1 e 10}
\FunctionTok{rand}\NormalTok{(}\DataTypeTok{Bool}\NormalTok{) }\CommentTok{\# devolve verdadeiro ou falso}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Mas, antes de ver um código com rand(). Vamos pensar em um problema da
vida real. Imagine que temos que fazer um sorteio justo, e o único
instrumento que possuímos para o sorteio é uma moeda viciada. Que tem
como resultado muito mais faces do que coroas. Dá para usar essa moeda
em um sorteio justo?

A ideia para resolver o problema é olhar para pares de sorteios. Ou
seja, vamos ignorar sorteios onde tenhamos duas faces ou duas coroas.
Nos outros, teremos uma coroa e uma face ou vice versa. As chances das
duas serão de 50\%. Logo podemos assim, corrigir a moeda viciada.

Para simplificar o exercício, a moeda pode devolver 0, ou 1,
correspondentes a cara ou a coroa. Observe a seguinte função que simula
uma moeda viciada.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sorteio}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{rand}\NormalTok{() }\OperatorTok{\textgreater{}} \FloatTok{0.90}
    \ControlFlowTok{return} \FloatTok{1}
  \ControlFlowTok{else} 
    \ControlFlowTok{return} \FloatTok{0}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sorteio (generic function with 1 method)
\end{verbatim}

Pode se observar que a função devolve 0 na maior parte das vezes.
Podemos inclusive ver isso, fazendo mil sorteios:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verificaSorteio}\NormalTok{()}
\NormalTok{   cara }\OperatorTok{=} \FloatTok{0}
\NormalTok{   coroa }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1000}
     \ControlFlowTok{if} \FunctionTok{sorteio}\NormalTok{() }\OperatorTok{==} \FloatTok{0}
\NormalTok{        cara }\OperatorTok{=}\NormalTok{ cara }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{else}
\NormalTok{        coroa }\OperatorTok{=}\NormalTok{ coroa }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \FunctionTok{println}\NormalTok{(}\StringTok{"O número de caras foi: "}\NormalTok{, cara,}\StringTok{" e de coroas foi :"}\NormalTok{, coroa)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verificaSorteio (generic function with 1 method)
\end{verbatim}

Mas, podemos corrigir o sorteio da seguinte forma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sorteioBom}\NormalTok{()}
\NormalTok{   sorteio1 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
\NormalTok{   sorteio2 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
   \ControlFlowTok{while}\NormalTok{ sorteio1 }\OperatorTok{==}\NormalTok{ sorteio2 }\CommentTok{\# se forem iguais, tente novamente}
\NormalTok{     sorteio1 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
\NormalTok{     sorteio2 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ sorteio1   }\CommentTok{\# ao termos um diferente, podemos devolver o primeiro sorteio}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sorteioBom (generic function with 1 method)
\end{verbatim}

Podemos usar o verificaSorteio para ver a diferença.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verificaSorteio}\NormalTok{()}
\NormalTok{   cara }\OperatorTok{=} \FloatTok{0}
\NormalTok{   coroa }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1000}
     \ControlFlowTok{if} \FunctionTok{sorteioBom}\NormalTok{() }\OperatorTok{==} \FloatTok{0}
\NormalTok{        cara }\OperatorTok{=}\NormalTok{ cara }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{else}
\NormalTok{        coroa }\OperatorTok{=}\NormalTok{ coroa }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \FunctionTok{println}\NormalTok{(}\StringTok{"O número de caras foi: "}\NormalTok{, cara,}\StringTok{" e de coroas foi :"}\NormalTok{, coroa)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verificaSorteio (generic function with 1 method)
\end{verbatim}

Podemos ainda aproximar o número de Euler (𝑒), constante matemática que
é a base dos logaritmos naturais, usando uma simulação probabilística. A
ideia por trás desse código é que o número médio de tentativas
necessárias para que a soma de números aleatórios entre 0 e 1 ultrapasse
1 se aproxima do valor de 𝑒. Isso é baseado em uma relação matemática
que conecta essa situação ao número 𝑒.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{calculaEuler}\NormalTok{(total)}
\NormalTok{    soma\_tentativas }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{total}
\NormalTok{        soma }\OperatorTok{=} \FloatTok{0.0}
\NormalTok{        tentativas }\OperatorTok{=} \FloatTok{0}      
        \ControlFlowTok{while}\NormalTok{ soma }\OperatorTok{\textless{}=} \FloatTok{1}   \CommentTok{\# Continue gerando números até a soma ultrapassar 1}
\NormalTok{            soma }\OperatorTok{+=} \FunctionTok{rand}\NormalTok{()     }\CommentTok{\# Gera número aleatório entre 0 e 1}
\NormalTok{            tentativas }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}        
\NormalTok{        soma\_tentativas }\OperatorTok{+=}\NormalTok{ tentativas     }\CommentTok{\# Somar o número de tentativas necessárias}
    \ControlFlowTok{end} 
    \ControlFlowTok{return}\NormalTok{ soma\_tentativas }\OperatorTok{/}\NormalTok{ total     }\CommentTok{\# A média do número de tentativas será uma estimativa de e}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (1000 iterações): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{1000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (100000 iterações): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{100000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (100000000 iterações): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{100000000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Estimativa de e (1000 iterações): 2.713
Estimativa de e (100000 iterações): 2.71589
Estimativa de e (100000000 iterações): 2.71811446
\end{verbatim}

Para terminar a aula vamos aplicar o método de Monte Carlo para o
cálculo de Pi. Imaginem o primeiro quadrante, onde temos um semi-círculo
de raio 1, dentro de um quadrado de lado 1. Podemos sortear valores, os
que sairem dentro do círculo podem contar para a área desse. Mais
informações podem ser vistas aqui
(https://pt.wikipedia.org/wiki/M\%C3\%A9todo\_de\_Monte\_Carlo)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{calculaPi}\NormalTok{(total)}
\NormalTok{   noAlvo }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ total}
\NormalTok{     x }\OperatorTok{=} \FunctionTok{rand}\NormalTok{() }\OperatorTok{/} \FloatTok{2.0} \CommentTok{\# gera um número entre 0 e 0.5}
\NormalTok{     y }\OperatorTok{=} \FunctionTok{rand}\NormalTok{() }\OperatorTok{/} \FloatTok{2.0}
     \ControlFlowTok{if} \FunctionTok{sqrt}\NormalTok{(x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{*}\NormalTok{ y) }\OperatorTok{\textless{}=} \FloatTok{0.5}
\NormalTok{       noAlvo }\OperatorTok{=}\NormalTok{ noAlvo }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \ControlFlowTok{return} \FloatTok{4} \OperatorTok{*}\NormalTok{ (noAlvo }\OperatorTok{/}\NormalTok{ total)  }\CommentTok{\# precisamos multiplicar para ter a área de 4 quadrantes}
\KeywordTok{end} 

\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{100}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{1000000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{1000000000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3.04
3.139624
3.141516436
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Entrada de dados e o começo de
listas}\label{entrada-de-dados-e-o-comeuxe7o-de-listas}

Nessa aula, temos dois tópicos principais, como fazer a entrada de
dados, através de comandos de entrada e com argumentos na linha de
comando. Além disso também veremos como tratar de um tipo especial de
variável, onde é possível, guardar mais de um valor.

\section{O comando input}\label{o-comando-input}

Quando queremos inserir dados, em Julia, basta colocar dados. Mas, como
podemos fazer para entrar dados em um programa comum?

Para isso temos o comando readline(), que interrompe a execução do
programa e espera pela entrada de uma String, o que ocorre quando a
tecla ``enter'' é pressionada.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Digite o seu nome"}\NormalTok{)}
\NormalTok{resposta }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\FunctionTok{println}\NormalTok{(}\StringTok{"O seu nome é: "}\NormalTok{, resposta)}
\end{Highlighting}
\end{Shaded}

Caso, ao rodar o programa, você digitar \texttt{Maria}, e pressionar a
tecla enter, a resposta final do seu programa será
\texttt{O\ seu\ nome\ é:\ Maria}.

Como o readline() lê Strings, se quisermos ler números, é necessário
usar o comando parse. O comando parse de forma simples possui dois
parâmetros, o primeiro corresponde ao tipo que se quer transformar, e o
segundo o valor original.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Digite um inteiro"}\NormalTok{)}
\NormalTok{valor }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
\FunctionTok{println}\NormalTok{(}\StringTok{"O numero digitado foi "}\NormalTok{, valor)}
\end{Highlighting}
\end{Shaded}

Sabendo ler números do teclado, vamos a um exercício simples, ler uma
sequência de números inteiros terminada por zero e devolver a sua soma.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaVarios}\NormalTok{()}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0.0}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um número"}\NormalTok{)}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
    \ControlFlowTok{while}\NormalTok{  n}\OperatorTok{!=}\FloatTok{0}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ n}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um número"}\NormalTok{)}
\NormalTok{        n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A soma é: "}\NormalTok{, soma)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Observe o seguinte exemplo que calcula os quadrados dos números de uma
lista terminada por zero.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{leQ}\NormalTok{()}
\NormalTok{  x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{  n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
  \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{!=} \FloatTok{0}
    \FunctionTok{println}\NormalTok{(}\StringTok{"}\SpecialCharTok{$}\NormalTok{n}\StringTok{ ao quadrado é "}\NormalTok{, n }\OperatorTok{*}\NormalTok{ n)}
\NormalTok{    x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Notem que o readline também pode receber uma variável de arquivo para
que dados sejam lidos diretamente. Mas, nesse caso temos que tomar
Ocuidado para abrir (open()) e fechar (close()) o arquivo. Como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{leQ}\NormalTok{()}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um número"}\NormalTok{)}
\NormalTok{    f }\OperatorTok{=} \FunctionTok{open}\NormalTok{(}\StringTok{"numeros.txt"}\NormalTok{, }\StringTok{"r+"}\NormalTok{)}
\NormalTok{    x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{(f)}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
    \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{!=} \FloatTok{0}
        \FunctionTok{println}\NormalTok{(}\StringTok{"}\SpecialCharTok{$}\NormalTok{n}\StringTok{ ao quadrado é "}\NormalTok{, n }\OperatorTok{*}\NormalTok{ n)}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Digite outro número"}\NormalTok{)}
\NormalTok{        x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{(f)}
\NormalTok{        n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
    \ControlFlowTok{end}
    \FunctionTok{close}\NormalTok{(f)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Lendo através da linha de
comando}\label{lendo-atravuxe9s-da-linha-de-comando}

A outra forma de ler comandos é através da constante ARGS que é
preparada na chamada de um programa. Para entender melhor isso, vamos
ver o seguinte programa.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Se a linha acima está no arquivo args.jl, ao chamar julia args.jl com
diversos parâmetros, teremos diversos resultados diferentes.

Por exemplo ao chamar:

julia args.jl 1 2 3 abc

Teremos como resposta

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"3"}\NormalTok{, }\StringTok{"abc"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Vamos analisar um pouco melhor essa resposta observando que cada
parâmetro está em uma posição.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"O tamanho dos argumentos é: "}\NormalTok{, tam)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{tam}
    \FunctionTok{println}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{[i])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Olhando o código acima, podemos ver que a função length() devolve o
número de argumentos, ou seja, o tamanho da lista ARGS. Além disso com
os colchetes é possível acessar a cada posição da lista de forma
individual.

O exemplo abaixo soma os parâmetros inteiros dados como argumentos. Ele
também ilustra uma boa prática que é, sempre colocar o código em
módulos, no caso abaixo em funções:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{SomaEntrada}\NormalTok{()}
\NormalTok{    tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\NormalTok{    s }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tam}
\NormalTok{        valor }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int}\NormalTok{, }\ConstantTok{ARGS}\NormalTok{[i])}
        \FunctionTok{println}\NormalTok{(valor)}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ s }\OperatorTok{+}\NormalTok{ valor}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A soma foi: "}\NormalTok{, s)}
\KeywordTok{end}
\FunctionTok{SomaEntrada}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

A flexibilidade que temos ao usar listas é enorme! Por isso, listas ou
vetores, merecem um tópico próprio.

\section{Listas}\label{listas}

Vamos primeiro brincar um pouco no console.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vetor }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{println}\NormalTok{(vetor[}\FloatTok{1}\NormalTok{])}
\FunctionTok{println}\NormalTok{(}\FunctionTok{length}\NormalTok{(vetor))}
\NormalTok{vetor[}\FloatTok{2}\NormalTok{] }\OperatorTok{=}\NormalTok{ vetor[}\FloatTok{2}\NormalTok{] }\OperatorTok{+} \FloatTok{1}
\NormalTok{vetor[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FloatTok{2} \OperatorTok{*}\NormalTok{ vetor[}\FloatTok{3}\NormalTok{]}
\FunctionTok{println}\NormalTok{(vetor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
3
[6, 3, 3]
\end{verbatim}

Como disse antes, o for foi feito para manipular vetores, vamos ver umas
funções, a primeira que imprime os elementos de um vetor um por linha.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeVetor}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ el }\KeywordTok{in}\NormalTok{ v}
        \FunctionTok{println}\NormalTok{(el)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Isso também pode ser feito por meio dos índices do vetor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeVetor}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{lenght}\NormalTok{(v)}
        \FunctionTok{println}\NormalTok{(v[i])}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Como cada posição é independente, podemos calcular a soma dos elementos
ímpares de um vetor

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaImpVetor}\NormalTok{(v)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(v)}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\%} \FloatTok{2} \OperatorTok{==} \FloatTok{1}
\NormalTok{            soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ v[i]}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Também vimos em aula alguns outros exemplos, como calcular a média dos
elementos em um vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{mediaV}\NormalTok{(v)}
\NormalTok{   soma }\OperatorTok{=} \FloatTok{0.0}
   \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
\NormalTok{      soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ i}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ soma }\OperatorTok{/} \FunctionTok{length}\NormalTok{(v)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Devolver a soma dos elementos ímpares de um vetor

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaImpar}\NormalTok{(v)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{2} \OperatorTok{==} \FloatTok{1}
\NormalTok{            soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ i}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Imprimir os números divisíveis por 5 de um vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeDivisivelPor5}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{5} \OperatorTok{==} \FloatTok{0}
            \FunctionTok{println}\NormalTok{(i)}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Com uma pequena variação e usando o comando push!() podemos ver como
devolver um vetor com os números divisíveis por 5.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{devolveDivisivelPor5}\NormalTok{(v)}
\NormalTok{    x }\OperatorTok{=}\NormalTok{ []  }\CommentTok{\# começa com um vetor vazio}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{5} \OperatorTok{==} \FloatTok{0}
            \FunctionTok{push!}\NormalTok{(x, i)  }\CommentTok{\# adiciona um elemento ao vetor x}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ x}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Álgebra linear e Listas}\label{uxe1lgebra-linear-e-listas}

A manipulação de listas é uma parte fundamental da álgebra linear, que
estuda vetores e matrizes. Funções como o produto escalar de dois
vetores são exemplos clássicos. Abaixo temos dois exemplos de produto
escalar de dois vetores. lembrado esse é definido como a soma dos
produtos de elementos em posições iguais.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{dotProduct}\NormalTok{(a, b)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(a) }\OperatorTok{!=} \FunctionTok{length}\NormalTok{(b)}
       \ControlFlowTok{return}\NormalTok{ soma   }\CommentTok{\# o produto não está definido se os tamanhos são diferentes}
    \ControlFlowTok{end}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(a)}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ a[i] }\OperatorTok{*}\NormalTok{ b[i]}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Acima vimos que um caso especial do uso do for, consiste em fazer Ofor
varias entre 1 e um tamanho (1:lenght(a))

Observem a diferença na versão abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{dotProduct}\NormalTok{(a, b)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(a) }\OperatorTok{!=} \FunctionTok{length}\NormalTok{(b)}
       \ControlFlowTok{return}\NormalTok{ soma   }\CommentTok{\# o produto não está definido se os tamanhos são diferentes}
    \ControlFlowTok{end}   
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ a}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ x }\OperatorTok{*}\NormalTok{ b[i]}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end} 
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Exercício de
permutação}\label{exercuxedcio-de-permutauxe7uxe3o}

Para terminar, vamos fazer uma função onde dado um vetor de inteiros de
tamanho \(n\), verifica se esse vetor é uma permutação dos números de 1
a \(n\). Para isso, veremos se cada número de 1 a \(n\) está no vetor.

Mas, sem esquecer dos testes:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@testset} \StringTok{"Verifica Permutação"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

e o código:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permuta}\NormalTok{(v)}
\NormalTok{   tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(v)}
   \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{tam}
      \ControlFlowTok{if}\NormalTok{  !(i }\KeywordTok{in}\NormalTok{ v)}
         \ControlFlowTok{return} \ConstantTok{false}
      \ControlFlowTok{end}
   \ControlFlowTok{end}
   \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Foi usado o comando in de Julia que verifica se um elemento está no
vetor.

\bookmarksetup{startatroot}

\chapter{Exercícios com vetores}\label{exercuxedcios-com-vetores}

Os vetores permitem que sejam realizados algoritmos bem mais complexos,
nesse capítulo veremos algums exercícios.

\section{Permutação}\label{permutauxe7uxe3o}

Dado um vetor com inteiros, queremos verificar se esse vetor contém uma
permutação. Para isso, temos que verificar em um vetor de tamanho n, se
ele contém os números de 1 a n exatamente uma vez cada 1. O vetor {[}3,
1, 2{]} é uma permutação, pois tem tamanho 3 e os elementos de 1 a 3
aparecem uma vez.

Uma forma de se resolver esse problema é por meio de um indicador de
passagem. Inicialmente vamos supor que o vetor é uma permutação, em
seguida verificamos se todos os números entre 1 e n estão no vetor. Isso
pode ser feito com comando in, que verifica se um elemento pertence ao
vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permutação}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
        \ControlFlowTok{if}\NormalTok{ !(i }\KeywordTok{in}\NormalTok{ l)}
\NormalTok{            perm }\OperatorTok{=} \ConstantTok{false}
        \ControlFlowTok{end}    
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
permutação (generic function with 1 method)
\end{verbatim}

Uma outra alternativa é verificar se para cada elemento do vetor, se ele
está entre 1 e n, e é unico. Ou seja, verificamos se o primeiro elemento
está entre 1 e n, e depois percorremos o vetor para ver se ele é único.
Em seguida fazemos isso para os elementos seguintes. O código fica:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permutação}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
        \ControlFlowTok{if}\NormalTok{ (l[i] }\OperatorTok{\textgreater{}}\NormalTok{ tamanho }\OperatorTok{||}\NormalTok{ l[i] }\OperatorTok{\textless{}=} \FloatTok{0}\NormalTok{)}
\NormalTok{            perm }\OperatorTok{=} \ConstantTok{false}
        \ControlFlowTok{end}
\NormalTok{        j }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+}\FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
            \ControlFlowTok{if}\NormalTok{ l[j] }\OperatorTok{==}\NormalTok{ l[i]}
\NormalTok{                perm }\OperatorTok{=} \ConstantTok{false}
            \ControlFlowTok{end}
\NormalTok{            j }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
permutação (generic function with 1 method)
\end{verbatim}

Uma outra alternativa é ter um vetor auxiliar onde contamos as
ocorrências de cada número entre 1 e n. Ao final, todos os elementos
desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e já
colocamos os testes automatizados.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{permutação}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    aux }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, tamanho)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ l}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1} \OperatorTok{||}\NormalTok{ i }\OperatorTok{\textgreater{}}\NormalTok{ tamanho}
\NormalTok{        perm }\OperatorTok{=} \ConstantTok{false}
      \ControlFlowTok{else}
\NormalTok{        aux[i] }\OperatorTok{+=} \FloatTok{1}
      \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ aux}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{!=} \FloatTok{1}
\NormalTok{        perm }\OperatorTok{=} \ConstantTok{false}
      \ControlFlowTok{end}
    \ControlFlowTok{end}  
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}

\PreprocessorTok{@testset} \StringTok{"Verifica Permutação"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([}\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\OperatorTok{{-}}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{5}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permutação}\NormalTok{([])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{0}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permutação}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:       | Pass  Total  Time
Verifica Permutação |   12     12  0.1s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Verifica Permutação", Any[], 12, false, false, true, 1.729792205835976e9, 1.729792205941158e9, false, "/workspaces/livro-alfredo/aulas/112.qmd")
\end{verbatim}

\section{Histograma}\label{histograma}

Já que vimos o exemplo anterior onde ``contamos'' o número, podemos ir
um pouco além e calcular o histograma de um vetor com números entre 1 e
10.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{histograma}\NormalTok{(l)}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{]}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{        valor\_atual }\OperatorTok{=}\NormalTok{ l[i]}
        \ControlFlowTok{if}\NormalTok{ valor\_atual }\OperatorTok{\textgreater{}=} \FloatTok{1} \OperatorTok{\&\&}\NormalTok{ valor\_atual }\OperatorTok{\textless{}=} \FloatTok{10}
\NormalTok{           result[valor\_atual] }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ result}
\KeywordTok{end}

\PreprocessorTok{@testset} \StringTok{"Verifica Histograma"} \ControlFlowTok{begin}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\OperatorTok{{-}}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{10}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{11}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{1}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{5}\NormalTok{,}\FloatTok{6}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{8}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{2}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([])}
    \ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:       | Pass  Total  Time
Verifica Histograma |    7      7  0.1s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Verifica Histograma", Any[], 7, false, false, true, 1.729792206375156e9, 1.729792206428047e9, false, "/workspaces/livro-alfredo/aulas/112.qmd")
\end{verbatim}

\section{Modelando problemas com o
computador}\label{modelando-problemas-com-o-computador}

O computador pode ser uma ferramenta bem poderosa para a modelagem de
problemas reais. Para isso vamos pegar o caso do problema dos
aniversários. Esse problema também é conhecido pelo paradoxo do
aniversário: Calcular a probabilidade de que em uma sala com n pessoas,
pelo menos duas possuam a mesma data de aniversário. Esse problema pode
ser resolvido usando probabilidade, por meio da qual se descobre que se
a sala tem 23 pessoas a chance de duas terem a mesma data é de pouco
mais de 50\%.

Mas, também podemos modelar esse problema computacionalmente. Para isso,
o primeiro passo é simplificar as datas, ao invés de mês e ano, podemos
codificar os dias em um número entre 1 e 365, sendo que 1 corresponderia
a primeiro de janeiro. Para resolver o problema, podemos sortear n
datas, e ver se há alguma repetição, se houver encontramos duas pessoas
com a mesma data.

Isso está representado na função experimento\_niver abaixo. Mas, para
saber a chance real, temos que repetr o experimento várias vezes. Na
função main() abaixo, pedimos a quantidade de experimentos e o número de
pessoas para executar a simulação.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{experimento\_niver}\NormalTok{(n)}
\NormalTok{    repetiu }\OperatorTok{=} \ConstantTok{false}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    nivers }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ n }\OperatorTok{\&\&}\NormalTok{ (repetiu }\OperatorTok{==} \ConstantTok{false}\NormalTok{)}
\NormalTok{        niver }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{365}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{ niver }\KeywordTok{in}\NormalTok{ nivers}
\NormalTok{            repetiu }\OperatorTok{=} \ConstantTok{true}
        \ControlFlowTok{end}
        \FunctionTok{push!}\NormalTok{(nivers, niver)}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ repetiu}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{main}\NormalTok{()}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Quantos experimentos? "}\NormalTok{)}
\NormalTok{    quantas }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Quantas pessoas? "}\NormalTok{)}
\NormalTok{    npessoas }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{    quantas }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, quantas)}
\NormalTok{    npessoas }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, npessoas)}
\NormalTok{    sucessos }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ quantas}
        \ControlFlowTok{if} \FunctionTok{experimento\_niver}\NormalTok{(npessoas)}
\NormalTok{            sucessos }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A probabilidade estimada é "}\NormalTok{, }\FloatTok{100}\OperatorTok{*}\NormalTok{sucessos}\OperatorTok{/}\NormalTok{quantas, }\StringTok{"\%"}\NormalTok{)}
\KeywordTok{end}
\FunctionTok{main}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

A parte interessante é que podemos com pequenas variações ter outros
experimentos, como verificar se mais do que duas pessoas fazem
aniversário na mesma data. Para isso, abaixo, contamos o número de
repetições.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{experimento\_niver}\NormalTok{(n)}
\NormalTok{    repetiu }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    nivers }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ n}
\NormalTok{        niver }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{365}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{ niver }\KeywordTok{in}\NormalTok{ nivers}
\NormalTok{            repetiu }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
        \FunctionTok{push!}\NormalTok{(nivers, niver)}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ repetiu }\OperatorTok{\textgreater{}=} \FloatTok{2}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
experimento_niver (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Modelando um problema maior}\label{modelando-um-problema-maior}

Nessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele
os jogadores devem tentar chegar mais perto da soma de cartas 21, sem
estourar. Quem chegar mais perto ganha.

Cada jogador começa com duas cartas, sendo que as cartas tem o seu valor
nominal, as figuras (J, Q, K), que valem 10. Além disso, o Ás, pode
valer 1 ou 11. O que for mais vantajoso para o jogador.

Para começar vamos fazer uma simulação com um baralho, ou seja 52
cartas. Já que{]} para o jogo, não importa o naipe da carta, vamos supor
que existem quatro cartas de cada. Para isso, vamos criar duas funções,
uma que cria um baralho e o guarda em um vetor, e uma segunda que pega
uma carta do baralho. Nessa segunda função temos que ``retirar'' a carta
do vetor. Caso já não exista a carta do tipo desejado, temos que sortear
uma nova carta.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{13}\NormalTok{)}
\NormalTok{  i }\OperatorTok{=} \FloatTok{1}
  \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{14}
\NormalTok{    cards[i] }\OperatorTok{=} \FloatTok{4}
\NormalTok{    i }\OperatorTok{+=} \FloatTok{1}
  \ControlFlowTok{end}
  \ControlFlowTok{return}\NormalTok{ cards}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{pegarCarta}\NormalTok{(cards)}
\NormalTok{  sorteio }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{13}\NormalTok{)}
  \ControlFlowTok{while}\NormalTok{ cards[sorteio] }\OperatorTok{==} \FloatTok{0}
\NormalTok{    sorteio }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{13}\NormalTok{)}
  \ControlFlowTok{end}
\NormalTok{  cards[sorteio] }\OperatorTok{{-}=} \FloatTok{1}
  \ControlFlowTok{if}\NormalTok{ sorteio }\OperatorTok{\textgreater{}} \FloatTok{10}  \CommentTok{\# se a carta for figura, ela vale 10}
\NormalTok{    sorteio }\OperatorTok{=} \FloatTok{10}
  \ControlFlowTok{end}  
  \ControlFlowTok{return}\NormalTok{ sorteio}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pegarCarta (generic function with 1 method)
\end{verbatim}

De posse dessas duas funções, podemos criar outras que simulam o
comportamento dos jogadores. Vamos usar algumas estratégias simples,
como o jogador que fica com as duas cartas que recebeu.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  carta1 }\OperatorTok{=} \FunctionTok{pegarCarta}\NormalTok{(cards)}
\NormalTok{  carta2 }\OperatorTok{=} \FunctionTok{pegarCarta}\NormalTok{(cards)}
  \ControlFlowTok{if}\NormalTok{ carta1 }\OperatorTok{==} \FloatTok{1} \OperatorTok{||}\NormalTok{ carta2 }\OperatorTok{==} \FloatTok{1}
    \ControlFlowTok{return}\NormalTok{ carta1 }\OperatorTok{+}\NormalTok{ carta2 }\OperatorTok{+} \FloatTok{10}
  \ControlFlowTok{else}
    \ControlFlowTok{return}\NormalTok{ carta1 }\OperatorTok{+}\NormalTok{ carta2}
  \ControlFlowTok{end}  
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador1 (generic function with 1 method)
\end{verbatim}

Notem que acima, usamos a estratégia de usar o Ás da forma mais
vantajosa.

Para os outros jogadores, vamos usar estratégias mais elaboradas, ou
seja o jogador fica pegando cartas enquanto não chegar a um valor
pré-determinado, como por exemplo 21, 19, 17, 15 e 13.

Como cada jogador pode ter um número grande de cartas e no caso dele ter
um Ás, a conta tem que ser feita da maneira mais vantajosa, vamos usar
uma função que recebe um vetor de cartas e calcula a soma.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaCartas}\NormalTok{(c)}
\NormalTok{  soma }\OperatorTok{=} \FloatTok{0}
\NormalTok{  temAz }\OperatorTok{=} \ConstantTok{false}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ c}
\NormalTok{    soma }\OperatorTok{+=}\NormalTok{ i}
    \ControlFlowTok{if}\NormalTok{ c }\OperatorTok{==} \FloatTok{1} 
\NormalTok{      temAz }\OperatorTok{=} \ConstantTok{true}
    \ControlFlowTok{end}
  \ControlFlowTok{end}
  \ControlFlowTok{if}\NormalTok{ soma }\OperatorTok{\textless{}=} \FloatTok{11} \OperatorTok{\&\&}\NormalTok{ temAz}
      \ControlFlowTok{return}\NormalTok{ soma }\OperatorTok{+} \FloatTok{10}
  \ControlFlowTok{else} 
      \ControlFlowTok{return}\NormalTok{ soma}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
somaCartas (generic function with 1 method)
\end{verbatim}

De posse do soma cartas, podemos modelar os jogadores.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{21}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{19}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{17}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

  \KeywordTok{function} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{    cartas }\OperatorTok{=}\NormalTok{ []}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{15}
      \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
  \KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador6}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{13}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador6 (generic function with 1 method)
\end{verbatim}

Agora que temos todos os jogadores, podemos modelar uma partida. Para
isso criamos um baralho e fazemos com que cada jogador siga a sua
estratégia

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{  jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador6}\NormalTok{(cards)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

Não deu tempo de continuar, ficou para a próxima aula.

\bookmarksetup{startatroot}

\chapter{Continuando a modelagem}\label{continuando-a-modelagem}

No capítulo anterior ficamos com uma partida, mas sem a verificação do
vencedor, ou seja o jogador com o maior valor, menor ou igual a 21. Uma
decisão de projeto é dizer que no caso de empate, os jogadores, com os
maiores valores ganham e dividem o prêmio.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{  jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador6}\NormalTok{(cards)}
  \ControlFlowTok{return}\NormalTok{ jogadores}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

Logo, a partida devolve a pontuação de cada jogador, para podermos
verificar na rotina ganhador quem ganhou.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{ganhador}\NormalTok{(v)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    maximo }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(v)}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\textgreater{}} \FloatTok{21}  \CommentTok{\# se estourou é como se tivesse o menor valor}
\NormalTok{            v[i] }\OperatorTok{=} \FloatTok{0}
        \ControlFlowTok{end}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\textgreater{}}\NormalTok{ maximo}
\NormalTok{            maximo }\OperatorTok{=}\NormalTok{ v[i]  }\CommentTok{\# encontra o vencedor}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
\NormalTok{    result }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FunctionTok{length}\NormalTok{(v))}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(v)}
            \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{==}\NormalTok{ maximo}
\NormalTok{                result[i] }\OperatorTok{=} \FloatTok{1}
            \ControlFlowTok{end}
\NormalTok{            i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
        \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ result}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ganhador (generic function with 1 method)
\end{verbatim}

A rotinha ganhador devolve um vetor com os vencedores, com 1 na posição
de quem ganhou e zero na posição dos perdedores.

Uma das vantagens de se usar um computador é que podemos ter milhares de
partidas de 21 para encontrar qual seria a melhor estratégia.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{porcentagem}\NormalTok{()}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    porc }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{6}\NormalTok{)}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{100000}
\NormalTok{        porc }\OperatorTok{=}\NormalTok{ porc }\OperatorTok{+} \FunctionTok{ganhador}\NormalTok{(}\FunctionTok{partida}\NormalTok{())}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(porc)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
porcentagem (generic function with 1 method)
\end{verbatim}

Ao simularmos o jogo 10000 vezes, podemos encontrar qual é a melhor
estratégia dentre as que foram apresentadas.

O código acima ficou relativamente grande, e uma das coisas que podemos
notar é que há muita duplicação nos códigos dos Jogadores a partir do
segundo. Um dos maiores problemas de código é a duplicação. No caso
acima, podemos evitá-la adicionando um parâmetro à função Jogador, de
forma que esse seja o limite a ser considerado no laço. A função
jogador2 fica assim:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador2}\NormalTok{(cards, valor)}
\NormalTok{    cartas }\OperatorTok{=}\NormalTok{ []}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}}\NormalTok{ valor}
       \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador2 (generic function with 1 method)
\end{verbatim}

Como a função tem um parâmetro novo, temos que acertar a partida. Mas,
agora podemos usar todos os valores.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{   cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{   jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{   jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{21}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{20}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{19}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{18}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{17}\NormalTok{)}
   \ControlFlowTok{return}\NormalTok{ jogadores}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

Notem que não há mudança na função ganhador, que continua funcionando.

Para terminar, podemos ter agora uma versão interativa que permite que
um jogador humano jogue com o computador.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partidaComHumano}\NormalTok{()}
\NormalTok{    cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{    humano }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    computador }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{19}\NormalTok{)}
    \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O humano tem "}\NormalTok{, humano, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(humano))}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O humano quer mais cartas (S/N)?"}\NormalTok{)}
\NormalTok{    resp }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \ControlFlowTok{while}\NormalTok{ resp }\OperatorTok{==} \StringTok{"S"} \OperatorTok{||}\NormalTok{ resp }\OperatorTok{==} \StringTok{"s"}
         \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O computador tem "}\NormalTok{, computador, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(computador))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O humano tem "}\NormalTok{, humano, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(humano))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O humano quer mais cartas (S/N)?"}\NormalTok{)}
\NormalTok{         resp }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O computador tem "}\NormalTok{, computador, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(computador))}
    \ControlFlowTok{if} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textless{}=} \FloatTok{21} \OperatorTok{\&\&} \FunctionTok{somaCartas}\NormalTok{(humano) }\OperatorTok{\textless{}=} \FloatTok{21}
         \ControlFlowTok{if} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FunctionTok{somaCartas}\NormalTok{(humano)}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Humano Perdeu"}\NormalTok{)}
         \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{==} \FunctionTok{somaCartas}\NormalTok{(humano)}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Empate"}\NormalTok{)}
         \ControlFlowTok{else}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Humano ganhou"}\NormalTok{)}
         \ControlFlowTok{end}
    \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FloatTok{21} \OperatorTok{\&\&} \FunctionTok{somaCartas}\NormalTok{(humano) }\OperatorTok{\textgreater{}} \FloatTok{21}
         \FunctionTok{println}\NormalTok{(}\StringTok{"os dois perderam"}\NormalTok{)}
    \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FloatTok{21}
         \FunctionTok{println}\NormalTok{(}\StringTok{"Humano ganhou"}\NormalTok{)}
    \ControlFlowTok{else}
         \FunctionTok{println}\NormalTok{(}\StringTok{"Computador ganhou"}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partidaComHumano (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Boas práticas}\label{boas-pruxe1ticas}

Vamos começar apresentando 3 boas práticas de programação. Na verdade há
uma área que cuida de desenvolvimento de software, a Engenharia de
Software. Vamos a elas:

\section{Uso de contratos}\label{uso-de-contratos}

Sempre que possível o código deve ser modular, ou seja estar repartido
em arquivos e ou funções. Cada tipo de função deve deixar claro quais
são os seus parâmetros e o que ela devolve. Isso pode ser feito usando
tipos.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}\OperatorTok{::}\DataTypeTok{Int64}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \FloatTok{2} 
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}  
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fatorial (generic function with 1 method)
\end{verbatim}

Com isso, fica claro o que a função recebe e devolve, e se for enviado
um tipo diferente do esperado, temos em erro imediato.

\subsection{Boa prática 1: Use tipos}\label{boa-pruxe1tica-1-use-tipos}

\section{Testes automatizados}\label{testes-automatizados}

Para evitar que apareçam erros, ou os populates bugs, uma forma eficaz é
escrever código que verifica o funcionamento do código. Se isso for
feito de forma automática, temos os testes automatizados.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{testaFat}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{3}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{==} \FloatTok{120}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{4}\NormalTok{) }\OperatorTok{==} \FloatTok{24}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaFat (generic function with 1 method)
\end{verbatim}

\subsection{Boa prática 2: Sempre que possível faça
testes}\label{boa-pruxe1tica-2-sempre-que-possuxedvel-fauxe7a-testes}

\section{Escreva código para humanos, não para
computadores}\label{escreva-cuxf3digo-para-humanos-nuxe3o-para-computadores}

Apesar dos computadores serem capazes de ler código nem sempre bem
formatado, é bem difícil para humanos lerem código de forma não padrão.
Por isso algumas dicas importantes são:

\begin{itemize}
\item
  Use identação. Com isso, os blocos ficam bem claros e é fácil
  identificar os laços, blocos de if e corpos de função;
\item
  Escolha bem o nome das variáveis e funções, isso ajuda muito quem for
  ler o código
\item
  Sempre que você identificar uma possibilidade de melhoria no código,
  implemente. Ainda melhor se você tiver testes automatizados, para
  verificar que a melhoria não quebrou o código.
\end{itemize}

\subsection{Boa prática 3: Escreva código para que outros
leiam}\label{boa-pruxe1tica-3-escreva-cuxf3digo-para-que-outros-leiam}

\section{Aplicando as boas
práticas}\label{aplicando-as-boas-pruxe1ticas}

Vamos agora resolver o seguinte problema, aplicando as práticas acima.
Dada um vetor com números reais, determinar os números que estão no
vetor e o número de vezes que cada um deles ocorre na mesma.

Ao analizar o problema, vemos que temos como entrada um vetor de número
reais, que pode conter repetições. Para determinar os números que estão
no vetor, podemos usar um outro vetor de saída. Sendo que o de entrada e
o de saída devem ser do tipo Float64. Além disso, para o vetor que
fornece a quantidade de números temos um vetor de inteiros. De posse
disso, já temos a assinatura da função.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contHist}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, el}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, qtd}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
contHist (generic function with 1 method)
\end{verbatim}

De posse dessa assinatura, já podemos escrever os testes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verifica}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, elementos}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, }
\NormalTok{     quant}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
\NormalTok{     el }\OperatorTok{=} \DataTypeTok{Float64}\NormalTok{[]}
\NormalTok{     quan }\OperatorTok{=} \DataTypeTok{Int64}\NormalTok{[]}
     \FunctionTok{contHist}\NormalTok{(v, el, quan)}
     \ControlFlowTok{if}\NormalTok{ el }\OperatorTok{==}\NormalTok{ elementos }\OperatorTok{\&\&}\NormalTok{ quan }\OperatorTok{==}\NormalTok{ quant}
        \ControlFlowTok{return} \ConstantTok{true}
     \ControlFlowTok{else}
        \ControlFlowTok{return} \ConstantTok{false}
     \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{testaLista}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{1.3}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{0.0}\NormalTok{, }\FloatTok{1.3}\NormalTok{], [}\FloatTok{1.3}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{0.0}\NormalTok{], [}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{], [}\FloatTok{1.0}\NormalTok{], [}\FloatTok{4}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{8.3}\NormalTok{], [}\FloatTok{8.3}\NormalTok{], [}\FloatTok{1}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{3.14}\NormalTok{, }\FloatTok{2.78}\NormalTok{, }\FloatTok{2.78}\NormalTok{], [}\FloatTok{3.14}\NormalTok{, }\FloatTok{2.78}\NormalTok{], [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{])}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaLista (generic function with 1 method)
\end{verbatim}

Finalmente, podemos escrever o código. A idea para escrever a solução é
simples, vamos percorrer o vetor de entrada. Para cada elemento, temos
duas possibilidades, se ele não tiver aparecido antes, temos que
adicionar o número ao vetor saída e marcar 1 ocorrência. Se já apareceu,
basta incrementar o número de ocorrências.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contHist}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, el}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, qtd}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ a }\KeywordTok{in}\NormalTok{ el}
\NormalTok{            i }\OperatorTok{=} \FloatTok{1}
            \ControlFlowTok{while}\NormalTok{ el[i] }\OperatorTok{!=}\NormalTok{ a}
\NormalTok{               i }\OperatorTok{+=} \FloatTok{1}
            \ControlFlowTok{end}
\NormalTok{            qtd[i] }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{else}
            \FunctionTok{push!}\NormalTok{(el, a)}
            \FunctionTok{push!}\NormalTok{(qtd, }\FloatTok{1}\NormalTok{)}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
contHist (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Indo além de uma dimensão
(Matrizes)}\label{indo-aluxe9m-de-uma-dimensuxe3o-matrizes}

Até o momento trabalhamos com estruturas com mais de uma dimensão, mas
sem olharmos muito bem o seu tipo. Nessa aula vamos procurar entender as
diferenças entre elas e como isso pode ser usado ao nosso favor.

Vamos começar com as listas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Int64} (alias for Array{Int64, 1})
\end{verbatim}

O tipo devolvido é: Vector\{Int64\} (alias for Array\{Int64, 1\}). No
caso isso significa que v é um vetor de inteiros, ou um array de uma
dimensão. Da mesma forma

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{3}\NormalTok{)}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Int64} (alias for Array{Int64, 1})
\end{verbatim}

Mas, vetores podem ser mais flexíveis, como por exemplo abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2.0}\NormalTok{, }\StringTok{"três"}\NormalTok{]}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Any} (alias for Array{Any, 1})
\end{verbatim}

Nesse caso o tipo de vetor, deixa de ser de inteiros e passa a ser
``Any'', ou seja Vector\{Any\} (alias for Array\{Any, 1\}).

Mais ainda, imaginem a seguinte situação:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{push!}\NormalTok{(v, a)}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Any} (alias for Array{Any, 1})
\end{verbatim}

Nesse caso, o vetor continua sendo do tipo Any, mas na quarta posição
temos um vetor com três inteiros. Com isso podemos ver que as estruturas
de vetores podem ser bem flexíveis. Mas, apesar disso, quando temos
estruturas de tipos diferentes, com muita flexibilidade, geralmente há
alguma penalidade de uso, geralmente no desempenho.

Por outro lado, podemos ter estruturas com mais de uma dimensão, no caso
elas são denominadas matrizes. Elas podem ser criadas com a função zeros
que já usamos acima.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\FunctionTok{typeof}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Matrix{Int64} (alias for Array{Int64, 2})
\end{verbatim}

Acima foi criada uma matriz de duas dimensões com 3 linhas e duas
colunas. Seus elementos podem se acessados como em um vetor, mas agora
com dois indíces.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m[}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{]  }\OperatorTok{=} \FloatTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Array\{Int64,2\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m[}\FloatTok{1}\NormalTok{])}
    \FunctionTok{println}\NormalTok{(m[}\FloatTok{2}\NormalTok{])}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \FunctionTok{println}\NormalTok{(i)}
    \ControlFlowTok{end}
 \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in}\NormalTok{ m[i]}
            \FunctionTok{println}\NormalTok{(j,}\StringTok{"  "}\NormalTok{)}
        \ControlFlowTok{end}   
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \FunctionTok{print}\NormalTok{(}\StringTok{"|"}\NormalTok{)}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in}\NormalTok{ i}
            \FunctionTok{print}\NormalTok{(j,}\StringTok{"  "}\NormalTok{)}
        \ControlFlowTok{end}
        \FunctionTok{println}\NormalTok{(}\StringTok{"|"}\NormalTok{)   }
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{1}\NormalTok{]}
        \FunctionTok{println}\NormalTok{(m[}\FloatTok{1}\NormalTok{])}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{1}\NormalTok{]}
\NormalTok{        j }\OperatorTok{=} \FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{2}\NormalTok{]}
            \FunctionTok{print}\NormalTok{(m[i, j], }\StringTok{" "}\NormalTok{)}
\NormalTok{            j }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
        \FunctionTok{println}\NormalTok{()   }
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{preencheMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(m)}
\NormalTok{        m[i] }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\DataTypeTok{Int}\NormalTok{) }\OperatorTok{\%} \FloatTok{10}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
preencheMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{criaIdentidate}\NormalTok{(tam}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
\NormalTok{    m }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, tam, tam)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tam}
\NormalTok{        m[i, i] }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ m  }
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
criaIdentidate (generic function with 1 method)
\end{verbatim}

Operações diretas com matrizes tipo +, - e *

\bookmarksetup{startatroot}

\chapter{Aula de exercícios sobre
Strings}\label{aula-de-exercuxedcios-sobre-strings}

Nesta aula, vamos explorar funções que manipulam strings e criar testes
para verificar sua correção. Em algumas funções, vamos notar que há
diversas formas de se obter o mesmo resultado

\section{1. Concatenação de letras}\label{concatenauxe7uxe3o-de-letras}

A primeira função \texttt{concatena} concatena as primeiras duas e as
últimas duas letras de uma string.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{concatena}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}\OperatorTok{::}\DataTypeTok{String}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(s) }\OperatorTok{\textless{}} \FloatTok{2}
        \ControlFlowTok{return} \StringTok{"Erro: tamanho da string menor do que 2"}
    \ControlFlowTok{end}
\NormalTok{    resposta }\OperatorTok{=}\NormalTok{ s[}\FloatTok{1}\OperatorTok{:}\FloatTok{2}\NormalTok{]}\OperatorTok{*}\NormalTok{s[}\KeywordTok{end}\OperatorTok{{-}}\FloatTok{1}\OperatorTok{:}\KeywordTok{end}\NormalTok{]}
    \ControlFlowTok{return}\NormalTok{ resposta}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
concatena (generic function with 1 method)
\end{verbatim}

Awui utulizamos \texttt{s{[}1:2{]}} para obter as duas primeiras letras
de s, que é uma forma mais concisa de acessar mais de um índice de um
objeto. Alternativamente, poderíamos acessar esses dois índices
separadamente com o comando \texttt{s{[}1{]}*s{[}2{]}}.

Para verificar se a função está funcionando corretamente, podemos
utilizar o seguinte teste:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{testeConcatena}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"Ola Bom Dia"}\NormalTok{) }\OperatorTok{==} \StringTok{"Olia"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"oi"}\NormalTok{) }\OperatorTok{==} \StringTok{"oioi"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"tre"}\NormalTok{) }\OperatorTok{==} \StringTok{"trre"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"a"}\NormalTok{) }\OperatorTok{==} \StringTok{"Erro: tamanho da string menor do que 2"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"a123"}\NormalTok{) }\OperatorTok{==} \StringTok{"a123"}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testeConcatena (generic function with 1 method)
\end{verbatim}

\section{2. Inversão de String}\label{inversuxe3o-de-string}

Devemos criar uma função que interte uma string, retornando os
caracteres na ordem reversa.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{inverte}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}\OperatorTok{::}\DataTypeTok{String}
    \CommentTok{\# Inicializamos uma string vazia}
\NormalTok{    inversa}\OperatorTok{=}\StringTok{""}

    \CommentTok{\# Intervalo de lenght(s) até 1, a passos de {-}1}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FunctionTok{length}\NormalTok{(s)}\OperatorTok{:{-}}\FloatTok{1}\OperatorTok{:}\FloatTok{1}
        \CommentTok{\# Concatena cada caractere na ordem inversa}
\NormalTok{        inversa}\OperatorTok{*=}\NormalTok{s[i]}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ inversa}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
inverte (generic function with 1 method)
\end{verbatim}

Para obter o resultado que desejamos, fazemos um laço \texttt{for} que
itera do último índice da string, representado por \texttt{length(s)},
até o primeiro, concatenando os caracteres nessa ordem na string de
retorno. O laço é configurado para decrementar o índice a cada iteração,
especificando -1 como passo. Isso nos permite acessar cada caractere da
string de trás para frente. E em cada iteração, concatenamos o caractere
atual, \texttt{s{[}i{]}}, à string \texttt{inversa}. Dessa forma, os
caracteres são adicionados na ordem inversa.




\end{document}
