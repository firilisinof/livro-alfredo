#+STARTUP: fold indent noinlineimages logdrawer
#+TITLE:  Alfredo's MAC0110 Journal
#+AUTHOR:      Alfredo Goldman
#+LANGUAGE:    bt-br
#+TAGS: noexport(n) ignore(i)
#+TAGS: engenharia algoritmo avançado funcional
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* Configurações LaTeX                                       :noexport:ignore:
:latex_headers:
#+LATEX_CLASS_OPTIONS: [11pt,a4paper]
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: \usepackage{amsmath,amsfonts,amssymb,amsthm}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \usepackage{colortbl}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage[brazilian]{babel}
#+LATEX_HEADER: \usepackage[scale=2]{ccicons}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{relsize}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage{pgfplots}
#+LATEX_HEADER: \usepackage{todonotes}
#+LATEX_HEADER: \usepgfplotslibrary{dateplot}
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller\relax}

#+LATEX_HEADER: \definecolor{Base}{HTML}{191F26}
#+LATEX_HEADER: \colorlet{Accent}{BrickRed}
#+LATEX_HEADER: \colorlet{CodeBg}{Gray!20}
#+LATEX_HEADER: \colorlet{CodeHighBg}{Accent!10}
#+LATEX_HEADER: \colorlet{Highlight}{Accent!18}

#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usemintedstyle{vs}
#+LATEX_HEADER: \setminted{
#+LATEX_HEADER:            frame=none,
#+LATEX_HEADER:            bgcolor=CodeBg,
#+LATEX_HEADER:            fontsize=\footnotesize,
#+LATEX_HEADER:            baselinestretch=1.2,
#+LATEX_HEADER:            framesep=0.6em,
#+LATEX_HEADER:            tabsize=2,
#+LATEX_HEADER:            breaklines
#+LATEX_HEADER: }

#+LATEX_HEADER: \AtBeginEnvironment{snugshade*}{\vspace{-0em}}
#+LATEX_HEADER: \AfterEndEnvironment{snugshade*}{\vspace{-0em}}

#+LATEX_HEADER: \usepackage{fancyvrb}
#+LATEX_HEADER: \usepackage{fvextra}
#+LATEX_HEADER: \RecustomVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\footnotesize,
#+LATEX_HEADER:                                                  breaklines=true,
#+LATEX_HEADER:                                                  frame=single,
#+LATEX_HEADER:                                                  framerule=1mm,
#+LATEX_HEADER:                                                  rulecolor=CodeBg}

#+LATEX_HEADER: \usepackage{DejaVuSansMono}
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller[2]\relax}
:end:

* Lista de Tarefas
** TODO Apêndice defendendo o uso de Julia, para iniciantes e para iniciados
:LOGBOOK:
- State "TODO"       from              [2021-10-05 Tue 16:06]
:END:
** TODO Categorizar headers e subheaders
:LOGBOOK:
- State "TODO"       from              [2021-10-05 Tue 16:06]
:END:
** TODO Mudar cores de seções categorizadas
:LOGBOOK:
- State "TODO"       from              [2021-10-05 Tue 16:06]
:END:
* Programa do curso
** Aula 01 - Visão Geral do Curso
:PROPERTIES:
:EXPORT_FILE_NAME: aula_01.pdf
:END:

Objetivo da aula: Dar uma ideia geral do que vai acontecer no semestre
*** Visão Geral do Curso
- Vamos começar  em um ambiente  amigável: console do Julia  ou o uso  do Replit
  (ambiente [[https://replit.com/][web]] com diversas linguagens)
- Em seguida vamos passar para linha de comando
  - Sim, compilação tem que ser explícita
- Após ver os primeiros programas em Julia
- Sim vamos ver outro paradigma: o funcional com Haskel
- Isso tudo cobrindo o conteúdo do curso
  - Sem esquecer de controle de versão e testes automatizados
*** Conhecendo um pouco a classe
  No  curso vamos  usar o  [[https://www.mentimeter.com][Menti]] uma  ferramenta
  para pesquisas  anônimas. Não  tenha medo você  não será  identificado!  Vamos
  começar:

 - Primeira Consulta:
    Quem já sabe programar?
 - Segunda Consulta:
    Qual a sua linguagem preferida?
 - Terceira Consulta:
    Qual o seu objetivo daqui a quatro anos?
*** Entendendo a necessidade de termos uma linguagem de programação
Vou precisar de dois voluntários

- Descrever como fritar um ovo para um extraterrestre?
- Descrever escovar os dentes para um homem pré histórico?

Para os dois casos, vamos abstrair que a linguagem falada e/ou escrita seja um
problema.

Um exemplo          popular         (geração         youtube):
[[https://www.youtube.com/watch?v=Ct-lOOUqmyY][Como    passar   manteiga    de
amendoim]]

De maneira geral, Uma linguagem de programação é uma forma de se expressar:

- Dados (números, letras, etc)
- Procedimentos (formas de manipular dados)

Só lembrando procedimentos também podem ser dados :)
*** Lógica de programação é uma coisa natural
Vamos ver um exemplo  da Internet, conhecido como teste de  Einsten, vou pegar a
formulação                                do                               sítio
[[https:://www.geniol.com.br/logica/problemas/teste-de-einstein/][Geniol]]
*** O curso em si
- Exercícios Programa
- Mini Exercícios Programa (correção binária)
- Provas

Programar  é como  andar  de  bicicleta, só  se  aprende  programando!  Plágio  é
inaceitável, com punições severas

Recomenda-se  fortemente  que os  alunos  usem  um  ambiente baseado  em  Linux!
Programadores raiz usam linha de comando!

Linguagem: Vamos começar com Julia

O meu objetivo com o curso é que vocês aprendam ao final:

- Princípios básicos de algoritmos (ementa do curso)
- noções de controle de versões com o Git
- Noções de como programar em diferentes linguagens
  - A linguagem é apenas a ferramenta!
- Testes automatizados

Se  você está  ansioso é  já quer  começar a  ver algum  material, tem  um livro
disponível:                                 o                                 de
[[https://benlauwens.github.io/ThinkJulia.jl/latest/book.html][Julia]].

** Aula 02 - Visão Geral da Evolução de Hardware e Linguagens
:PROPERTIES:
:EXPORT_FILE_NAME: aula_02.pdf
:END:

Objetivo da aula ter uma visão geral da evolução do Hardware e das linguagens de
programação

*** Uma Breve História da Computação
**** Pensamento Computational
***** Tecnologia Computacional na Antiguidade
***** Melhores e Piores Usos da Tecnologia Computacional
**** Computação na Antiguidade
***** O Ábaco e a Máquina de Anticítera
**** Computação Moderna
***** Século 19
***** Século 20
***** Linguagens de Programação
**** Computação e Ciência

*** Preparação para a próxima aula
Pode ser útil já ter o ambiente de desenvolvimento com Julia instalado.
**** TODO Falar mais sobre Linux?
:LOGBOOK:
- State "TODO"       from              [2020-02-21 Fri 14:59]
:END:
** Aula 03 - Usando o Interpretador (REPL) como Calculadora
:PROPERTIES:
:EXPORT_FILE_NAME: aula_03.pdf
:END:

Objetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir
a noção de variáveis
*** Começando com o modo interativo do Julia.
Quem quiser já pode instalar o ambiente de programação, usem esse [[https://julialang.org/][link]].

Dentro do Julia (após chamar julia na linha de comando), vamos começar com
contas com números inteiros:
#+begin_SRC julia :eval no-export :exports both
1 + 2
#+end_SRC


#+RESULTS:
: 3

#+begin_SRC julia :eval no-export :exports both
40 * 4
#+end_SRC

#+RESULTS:
: 160

Sim, como era de se esperar, podemos em Julia usar os operandos: +, - e *, o
resultado será como o esperado. Vejamos a seguir que com a divisão fica um pouco
diferente:

#+begin_SRC julia :eval no-export :exports both
84 / 2
#+end_SRC
#+RESULTS:
: 42.0

Notem que nesse caso, houve uma mudança de tipos, pois 84 e 2 são inteiros e o resultado
é um número em ponto flutuante (float), podemos ver isso, pois ao invés de 42, tivemos
como resultado 42.0.

Também é possível pedir o resultado inteiro usando o operador div:
#+begin_SRC julia :eval no-export :exports both
div(84,2)
#+end_SRC

#+RESULTS:
: 42

Ou de forma equivalente usando o operador \div (para conseguir ver o símbolo da divisão
é necessário digitar \div seguido da tecla <tab>)

Além das contas básicas, também dá para fazer a exponenciação:

#+begin_SRC julia :eval no-export :exports both
2^31
#+end_SRC

#+RESULTS:
: 2147483648

Expressões mais complexas também podem ser calculadas:

#+begin_SRC julia :eval no-export :exports both
23 + 2 * 2 + 3 * 4
 #+end_SRC

 #+RESULTS:
 : 39

 Sim, a precedência de operadores usual também é válida em Julia. Mas, segue a
 primeira lição de programação: *Escreva para humanos, não para máquinas*

 #+begin_SRC julia :eval no-export :exports both
23 + (2 * 2) + (3 * 4)
 #+end_SRC

Em Julia também podemos fazer operações com números em ponto flutuante:

 #+begin_SRC julia :eval no-export :exports both
23.5 * 3.14
#+end_SRC

#+RESULTS:
: 73.79

ou
 #+begin_SRC julia :eval no-export :exports both
12.5 / 2.0
#+end_SRC

#+RESULTS:
: 6.25

Acima temos mais um exemplo de código escrito para pessoas, ao se escrever
2.0 estamos deixando claro que o segundo parâmetro é um número float.

É importante saber que números em ponto flutuante tem precisão limitada, logo
não se espante com resultados inesperados como abaixo:

 #+begin_SRC julia :eval no-export :exports both
1.2 - 1.0
#+end_SRC

#+RESULTS:
: 0.19999999999999996

Erros como esse são bastante raros, tanto que usualmente confiamos plenamente nas
contas feitas com computadores e calculadoras. Mas, é bom saber que existem limitações.




#+begin_SRC julia :eval no-export :exports both
2.6 - 0.7 - 1.9
#+end_SRC

#+RESULTS:
: 2.220446049250313e-16

ou
#+begin_SRC julia :eval no-export :exports both
0.1 + 0.2
#+end_SRC

#+RESULTS:
: 0.30000000000000004

ou ainda

#+begin_SRC julia :eval no-export :exports both
10e15 + 1 - 10e15
#+end_SRC

#+RESULTS:
: 0.0

Esses problemas de precisão estão ligados a limitação de como os números são
representados no computador. De maneira simplificada, os valores no computador
são codificados em palavras, formadas por bits. Nos computadores modernos as
palavras tem 64 bits, ou 8 bytes.  Logo, uma outra limitação está ligada aos números
inteiros muito grandes

#+begin_SRC julia :eval no-export :exports both
2^63
#+end_SRC

#+RESULTS:
: -9223372036854775808

Mas, para um curso introdutório basta saber que existem essas limitações. Como
lidar com elas é parte de um curso mais avançado.

É importante notar que o erro acima é um *erro silencioso*, ou seja quanto estamos usando números inteiros, pode ocorrer que o número a ser representado não caiba no número de bits disponível, o que faz com que ocorra um erro.

Voltando para as contas. Um outro operador interessante é o % que faz o resto da divisão


#+begin_SRC julia :eval no-export :exports both
4 % 3
#+end_SRC

#+RESULTS: 4e403942-5d45-473a-90be-9b02690bbb25
: 1

Até agora vimos como trabalhar com um único valor, ou seja, como se fosse no
visor de uma calculadora. Mas, é possível ir além. Ao invés de termos teclas
de memória, o computador nos oferece variáveis. Elas são como nomes para valores
que queremos guardar e usar mais tarde.

Além das operações básicas também temos as operações matemáticas (funções), como por
exemplo o seno, sin em inglês. Para saber como uma função funciona podemos pedir ajuda ao
ambiente, usando uma "?", e em seguida digitando o que queremos saber, como por exemplo em:

ACERTAR FORMATAÇÃO
?sin

que nos responde:
earch: sin sinh sind sinc sinpi sincos sincosd sincospi asin using isinf asinh

  sin(x)

  Compute sine of x, where x is in radians.

  See also sind, sinpi, sincos, cis, asin.

  Examples
  ≡≡≡≡≡≡≡≡

  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)
  1×9 Matrix{Float64}:
   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0
  
  julia> sind(45)
  0.7071067811865476
  
  julia> sinpi(1/4)
  0.7071067811865475
  
  julia> round.(sincos(pi/6), digits=3)
  (0.5, 0.866)
  
  julia> round(cis(pi/6), digits=3)
  0.866 + 0.5im
  
  julia> round(exp(im*pi/6), digits=3)
  0.866 + 0.5im
...

Notem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender
o uso de uma função como sin. Vejamos agora a raiz quadrada:

?sqrt

search: sqrt isqrt

  sqrt(x)

  Return \sqrt{x}. Throws DomainError for negative Real arguments. Use complex
  negative arguments instead. The prefix operator √ is equivalent to sqrt.

  See also: hypot.

  Examples
  ≡≡≡≡≡≡≡≡

  julia> sqrt(big(81))
  9.0
  
  julia> sqrt(big(-81))
  ERROR: DomainError with -81.0:
  NaN result for non-NaN input.
  Stacktrace:
   [1] sqrt(::BigFloat) at ./mpfr.jl:501
  [...]
  
  julia> sqrt(big(complex(-81)))
  0.0 + 9.0im


Nela vemos que é possível calcular a raiz como em:
julia> sqrt(4)
2.0

julia> sqrt(4.0)
2.0

Mas, observamos também na documentação a função big(), que tem a seguinte ajuda:

help?> BigInt
search: BigInt disable_sigint reenable_sigint

  BigInt <: Signed

  Arbitrary precision integer type.

  ────────────────────────────────────────────────────────────────────────────

  BigInt(x)

  Create an arbitrary precision integer. x may be an Int (or anything that can
  be converted to an Int). The usual mathematical operators are defined for
  this type, and results are promoted to a BigInt.

  Instances can be constructed from strings via parse, or using the big string
  literal.

  Examples
  ≡≡≡≡≡≡≡≡

  julia> parse(BigInt, "42")
  42
  
  julia> big"313"
  313
  
  julia> BigInt(10)^19
  10000000000000000000


Com números BigInt, já não a problemas de estouro, como podemos ver abaixo:

julia> big(2) ^ 1002
42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504


*** Variáveis e seus tipos
Em Julia também temos o conceito de variáveis, que servem para armazenar os
diferentes conteúdos de dados possíveis.

#+begin_SRC julia :eval no-export :exports both
a = 7
2 + a
#+end_SRC

#+RESULTS:
: 7
: 9



É importante notar que as variáveis em Julia podem receber novos valores e o tipo
da variável depende do que foi atribuído por último.

#+begin_SRC julia :eval no-export :exports both
a = 3
a = a + 1
typeof(a)
#+end_SRC

#+RESULTS: 7f85f7ed-67f8-44e7-bd41-a5e59e70f3f8
: Int64

Aproveitando o momento, podemos ver que há vários tipos primitivos em Julia, sendo os
principais:

#+begin_SRC julia :eval no-export :exports both
typeof(1)
typeof(1.1)
typeof("Bom dia")
#+end_SRC

#+RESULTS:
: Int64
: Float64
: String


Falando em Strings, elas são definidas por conjuntos de caracteres entre aspas como:
#+begin_SRC julia :eval no-export :exports both
s1 = "Olha que legal"
s2 = "Outra String"
#+end_SRC



Dá também para fazer operações com strings como concatenação:

#+begin_SRC julia :eval no-export
s1 = "Tenha um"
s2 = " Bom dia"
s3 = s1 * s2
#+end_SRC

#+RESULTS:
: "Tenha um"
: " Bom dia"
: "Tenha um Bom dia"



Ou potência:

#+begin_SRC julia :eval no-export :exports both
s = "Nao vou mais fazer coisas que possam desagradar os meus colegas "
s ^ 10
#+end_SRC



#+RESULTS:
: "Nao vou mais fazer coisas que possam desagradar os meus colegas "
: "Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas "



Ainda sobre variáveis, há umas regras com relação aos seus nomes, tem que
começar com uma letra (ou com _), pode ter dígitos e não pode ser uma palavra reservada.  É
bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em
unicode, por exemplo o \Delta:

#+begin_SRC julia :eval no-export :exports both
Delta = 2  # Para se fazer o Delta, deve se digitar \ seguido de Delta, seguido de <tab>
#+end_SRC

#+RESULTS:

Mas, a linguagem vai bem além com caracteres de animais e símbolos:

#+begin_SRC julia :eval no-export :exports both
\:cat: = 5
\:dog: = 3
\:house: = 20
#+end_SRC

#+RESULTS:

Isso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem
bonitinhas.  A lista de figuras pode ser encontrada
[[https://docs.julialang.org/en/v1/manual/unicode-input/][aqui]]

*** Saída de dados
Para fazer saídas usam-se dois comandos, print() e o println(), sendo que o
primeiro não pula linha e o segundo pula.
#+begin_SRC julia :eval no-export :exports both
print("Hello ")
println("World!")
println("Ola, mundo!")
#+end_SRC

#+RESULTS:
: Hello World!
: Ola, mundo!


Para evitar que se digitem muitos caracteres, por vezes podemos usar "açucares sintáticos".

#+begin_SRC julia :eval no-export :exports both
x = 1
x = x + 1
x += 1  # forma equivalente a acima
#+end_SRC

Acima, vimos a forma de se inserir comentários em Julia (sim esses serão ignorados
pelo computador).

#+RESULTS:
: 1
: 2
: 3


Exercício:
Faça o passo a passo para encontrar as raízes da equação de segundo grau x^2 - 5 x + 6, usando
as váriaveis a, b, c, \Delta, x1 e x2.

** Aula 04 - Introdução a Funções
:PROPERTIES:
:EXPORT_FILE_NAME: aula_04.pdf
:END:

Objetivo: Começar a entender como funcionam as funções
*** O uso de funções é uma abstração natural
Na aula passada já vimos umas funções e isso foi bem natural, foram elas:
- typeof() - Dado um parâmetro devolve o seu tipo, sim variáveis estão
  associadas a tipos
- div() - Dados dois parâmetros devolve a divisão inteira do primeiro pelo segundo
- print() e println() - Dados diversos parâmetros os imprime, sem devolver nada
Inclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para saber o que fazem as
funções. Para isso, se usa o ? antes da função:
#+begin_SRC julia :eval no-export :exports both
?typeof()
?div()
?print()
#+end_SRC

#+RESULTS:



Ao fazer isso, inclusive descobrimos que o div() pode ser usado também como \div.

Uma outra função bem útil é a que permite transformar um tipo de valor em outro.

#+begin_SRC julia :eval no-export :exports both
parse(Float64, "32")
#+end_SRC

#+RESULTS:
: 32.0


Para conversão de valores em ponto flutuante para inteiros, temos a função trunc.

#+begin_SRC julia :eval no-export :exports both
trunc(Int64, 2.25)
#+end_SRC

#+RESULTS:
: 2


De forma inversa temos o float.

#+begin_SRC julia :results output :exports both :eval no-export
float(2)
#+end_SRC

#+RESULTS:
: 2.0



Finalmente, podemos transformar um valor em uma string, como em:

#+begin_SRC julia :results output :exports both :eval no-export
string(3)
#+end_SRC

#+RESULTS:
: "3"


ou
#+begin_SRC julia :results output :exports both :eval no-export
string(3.57)
#+end_SRC

#+RESULTS:
: "3.57"



Também tem muitas funções matemáticas prontas como
- sin(x) - calcula o seno de x em radianos
- cos(x) - calcula o cosseno de x em radianos
- tan(x) - calcula a tangente de x em radianos
- deg2rad(x) - converte x de graus em radianos
- rad2deg(x) - converte x de radianos em graus
- log(x) - calcula o logarítmo natural de x
- log(x, b) - calcula o logarítmo de x na base b
- log2(x) - calcula o logarítmo de x na base 2
- log10(x) - calcula o logarítmo de x na base 10
- exp(x) - calcula o expoente da base natural de x
- abs(x) - calcula o módulo de x
- sqrt(x) - calcula a raiz quadrada de x
- isqrt(x) - calcula a raiz quadrada inteira de x
- cbrt(x) - raiz cúbica de x
- factorial(x) - calcula o fatorial de x

A melhor forma de se acostumar a usar as funções é fazendo contas e
verificando os resultados. Uma dica importante é que para funções mais
complexas, pode ser que já existam funções prontas em Julia. Para isso
uma busca com as palavras chave. Um exemplo a seguir para procurar a função
para o cálculo de seno hiperbólico: "julia lang hiperbolic sin". A busca pelo
termo em inglês é uma boa dica para buscas em geral.

Em julia também é possível criar funções conforme as suas necessidades, como abaixo:
#+begin_SRC julia :eval no-export :exports both
function mensagemDeBomDia()
   println("Tenha um bom dia!")
end
#+end_SRC

#+RESULTS:
: mensagemDeBomDia (generic function with 1 method)

Para usar uma função, basta chamá-la:


#+begin_SRC julia :eval no-export :exports both
MensagemDeBomDia()
#+end_SRC

#+RESULTS:


Funções, podem receber um ou mais parâmetros:

#+begin_SRC julia :eval no-export :exports both
function imprime(a)
   println(" Vou imprimir ", a)
end
imprime(42)
#+end_SRC

#+RESULTS:
: imprime (generic function with 1 method)
:  Vou imprimir 42


Também é possível que uma função chame outra função como em:

#+begin_SRC julia :eval no-export :exports both
function imprimeduasvezes(a)
   imprime(a)
   imprime(a)
end
imprimeduasvezes(13)
#+end_SRC

#+RESULTS:
: imprimeduasvezes (generic function with 1 method)

Mais ainda, também é possível diferenciar funções por meio da quantidade
de parâmetros.

#+begin_SRC julia :eval no-export :exports both
function recebe(a)
  println("Recebi um parametro: ", a)
end
function recebe(a, b)
  println("Recebi dois parametros: ", a, " ", b)
end

#+end_SRC

#+RESULTS:
: recebe (generic function with 1 method)
: recebe (generic function with 2 methods)


Conforme a chamada, a função chamada será diferente:

#+begin_SRC julia :eval no-export :exports both
recebe(1)
recebe(1, 2)
#+end_SRC

#+RESULTS:


Também dá para chamar funções com variáveis e com operações, como
em:

#+begin_SRC julia :eval no-export :exports both
a = 10
recebe(a)
recebe(a, a + 1)
#+end_SRC

#+RESULTS:
: 10



As funções que vimos até agora imprimem mensagens, mas não devolvem nada.
O typeof() delas é nothing, ou seja, algo que não pode ser atribuído.

Mas, também é possível fazer funções que devolvem valores, como:

#+begin_SRC julia :eval no-export :exports both
function soma1(a)
  return a + 1
end
#+end_SRC

Nesse caso, se for passado um parâmetro numérico, a função devolverá o valor
incrementado (adicionado de 1).

Claro que isso pode ser usado com fórmulas mais complicadas como:

#+begin_SRC julia :eval no-export :exports both
function hipotenusa(a, b)
  hip = a * a + b * b
  return hip
end
#+end_SRC

**** TODO colocar mais para a frente
ou para a verificação de fórmulas, como relações trigonométricas:

#+begin_SRC julia :results output :async yes
function verificaequacao(x)
  soma = sin(x)^2 + cos(x)^2
  return soma == 1.0
end
#+end_SRC


** Aula 05 - Controle de Fluxo (Desvio Condicional) e Funções que se chamam
:PROPERTIES:
:EXPORT_FILE_NAME: aula_05.pdf
:END:

Antes de falar em desvio, vamos ver um novo tipo de variável que foi introduzido
de forma natural. O tipo booleando, ou seja uma variável que pode valer true
(verdadeiro) ou false (falso). O seu uso está intimamente ligado ao if.

Observem os seguintes exemplos:

#+begin_SRC julia :eval no-export :exports both
2 + 2 == 4
3 != 8
23 < 24
42 <= 44
42 < 2
#+end_SRC

#+RESULTS:
: true
: true
: true
: true
: false

Vale chamar a atenção, como em linguagens de programação o = é usado para
atribuições, para comparações se usa o $==$. Da mesma forma o != é usado como
diferente. Esses operadores, em conjunto com o $<, <=, >$ e $>=$ nos permitem
comparar valores.

Sobre as variáveis booleanas vale também observar o seu tipo.

#+begin_SRC julia :eval no-export :exports both
typeof(2 ==3)
#+end_SRC

#+RESULTS:
: Bool

Finalmente, também podemos negar variáveis booleanas para inverter o seu valor:
#+begin_SRC julia :eval no-export :exports both
!true
!false
#+end_SRC



Nessa aula, vamos aprender um novo comando.
O desvio condicional, através dele é possível alterar o fluxo de execução de um programa. Até o
momento não tínhamos comentado isso explicitamente, mas a ordem de execução de instruções segue
a ordem em que elas estão. Vejamos o exemplo abaixo:

#+begin_SRC julia :eval no-export :exports both
println("Oi")
println("um")
println("dois")
#+end_SRC

#+RESULTS:
: Oi
: um
: dois



A ordem de impressão será Oi, um e dois.

Da mesma forma não temos problema ao executar o código abaixo.

#+begin_SRC julia :eval no-export :exports both
denominador = 0
denominador += 2
30 / denominador
#+end_SRC

#+RESULTS:
: 0
: 2
: 15.0


Apesar da variável denominador começar inicialmente com 0, antes de se fazer a
divisão, ela estará valendo 2.

Como é de se esperar nem sempre queremos que essa ordem seja respeitada. Observe
o seguinte exemplo:


#+begin_SRC julia :eval no-export :exports both
pandemia = true
println("Vou sair de casa?")
if pandemia == true
   println("Só vou sair de casa se for essencial")
end
#+end_SRC

#+RESULTS:
: true
: Vou sair de casa?
: Só vou sair de casa se for essencial

 O exemplo acima é claro, se uma condição for verdadeira, o código que
 está no escopo do if (isso é entre a condição e o end) será executado.

 Um outro exemplo:

#+begin_SRC julia :eval no-export :exports both
denominador = 1
if denominador != 0
   println("sei fazer a divisão se não for por zero")
   println("o resultado da divisão de 30 por ", denominador, " é igual a ", 30/denominador)
end
 #+end_SRC

 #+RESULTS:
 : 1
 : sei fazer a divisão se não for por zero
 : o resultado da divisão de 30 por 1 é igual a 30.0



 Situações muito comuns em computação devem ser favorecidas pela linguagem, nesse
caso do if, é muito comum termos duas ou mais situações. Nesse sentido em Julia podemos
também ter alternativas como abaixo:

 #+begin_SRC julia :eval no-export :exports both
 pandemia = true
 println("Vou sair de casa?")
 if pandemia == true
    println("Só vou sair de casa se for essencial")
 else
    println("Balada liberada!!")
 end
 #+end_SRC

 #+RESULTS:
 : true
 : Vou sair de casa?
 : Só vou sair de casa se for essencial



No caso de termos mais de uma altenativa, não basta termos só uma condição,
nesse caso temos que usar elseif.

#+begin_SRC julia :eval no-export :exports both
pandemia = true
tenhoqueestudar = true
println("Vou sair de casa?")
if pandemia == true
   println("Só vou sair de casa se for essencial")
elseif tenhoqueestudar == true
   println("Melhor ficar em casa")
else
   println("Balada liberada")
end
#+end_SRC

#+RESULTS:
: true
: true
: Vou sair de casa?
: Só vou sair de casa se for essencial



 Conhecendo o if, agora, escreva uma função que recebe os coeficientes, a, b e c de uma
equação de segundo grau e imprime as suas raízes reais.

 Sim, a forma de se aprender a programar é programando.



 Vamos agora a parte mais importante do curso, lembrando que até o momento aprendemos:
**** valores
**** varíaveis e alguns dos seus tipos
**** Alguma funções já prontas como div(), typeof(), parse(), string(), println(), etc
**** como fazer as nossas funções com a palavra reservada function e que termina por end
***** lembrando que a função pode ou não devolver algo através do return
***** lembrando também que uma função pode chamar outra função
**** como mudar o fluxo de execução normal com o if, elseif






*** Agora sim: Funções que se chamam

Agora podemos, ir ao tópico principal da aula.

Observe a seguinte função imprime().

#+begin_SRC julia :eval no-export :exports both
function imprime()
    println("Mensagem positiva")
    imprime()
end
#+end_SRC

Ao ser chamada, o que acontece? O computador fará chamadas seguidas a função, imprimindo
a mensagem, até o momento que ocorra uma limitação de memória. Logo, fazer chamadas onde
uma função se chama, sem controle não é uma boa ideia.

Por outro lado, podemos pensar em uma forma de chamada controlada, onde a
própria função decide o momento de parar de se chamar. Para isso, vamos pegar uma
função matemática bem conhecida, o fatorial.

Sabemos que 5! = 5.4.3.2.1. Mais, ainda dado um número n, sabemos que n! = n.(n - 1)!
Continuando, temos que (n - 1)! = (n - 1).(n - 2)! e assim por diante. Para reproduzir
isso no computador precisamos saber quando parar. Para isso, podemos usar que o fatorial de
zero é 1, ou 0! = 1. Logo já temos a primeira parte da função:

#+begin_SRC julia :eval no-export :exports both
function fatorial(n)
  if n == 0
    return 1
  else
    # o que vamos colocar aqui?
end
#+end_SRC


No código acima, temos o critério de parada, ou seja quando n for igual a zero,
a resposta será 1. Mas, e se n não for zero. Nesse caso, temos que seguir a fórmula
da recursão ou seja n.(n - 1)!. Como (n - 1)! pode ser escrito como fatorial(n - 1).
Ficamos com a expressão n * fatorial(n - 1).

#+begin_SRC julia :eval no-export :exports both
function fatorial(n)
  if n == 0
    return 1
  else
    return n * fatorial(n - 1)
end

fatorial(5)
#+end_SRC

#+RESULTS:

Vamos a um segundo exemplo, a contagem regressiva. Mais uma vez, quando se chega a
zero, podemos considerar que a contagem terminou. Além disso, a cada número, o próximo
passo é o número menos 1.

#+begin_SRC julia :eval no-export :exports both
function contagem(n)
    if n < 0
        println("Bum!")
    else
        print(n, " ")
        contagem(n - 1)
    end
end
contagem(5)
#+end_SRC

#+RESULTS:
: contagem (generic function with 1 method)
: 5 4 3 2 1 0 Bum!


Essa estrutura é bem poderosa, pois permite que operações sejam executadas um
número controlado de vezes.  Voltando ao countdown, imagine que ao invés de
imprimir uma mensagem quiséssemos fazer uma conta com o que será devolvido.

#+begin_SRC julia :eval no-export :exports both
function soma(n)
  if n > 0
    return n + soma(n - 1)
  else
    return 1
  end
end
soma(11)
#+end_SRC

#+RESULTS:
: soma (generic function with 1 method)
: 67

 Essa estrutura é bastante poderosa e pode ser usada para o cálculo de produto, nesse
caso, a mudança é bem pequena.

Da mesma forma segue um exemplo para o cálculo dos n primeiros elementos da soma
hârmonica.

#+begin_SRC julia :eval no-export :exports both
function somaharmonica(atual, n)
  if atual >= n
    return 1.0 / atual
  else
    return 1.0 / atual + somaharmonica(atual + 1, n)
  end
end
somaharmonica(1, 10)
#+end_SRC

#+RESULTS:
: somaharmonica (generic function with 1 method)
: 2.9289682539682538


** Aula 06 - Funções que se chamam, continuação
:PROPERTIES:
:EXPORT_FILE_NAME: aula_06.pdf
:END:

Continuando com funções que se chamam, é bem importante saber que o nome dessa
técnica é a recursão.

Para compreender melhor a técnica, vamos ver um exemplo mais elaborado da função de contagem
regressiva:

#+begin_SRC julia :eval no-export :exports both
function contagem(n)
    if n <= 0
        println("Bum!")
    else
        println("O número agora é:", n)
        contagem(n - 1)
        println("Final dos passos para o número ", n)
    end
end
contagem(5)
#+end_SRC

#+RESULTS:
#+begin_example
contagem (generic function with 1 method)
O número agora é:5
O número agora é:4
O número agora é:3
O número agora é:2
O número agora é:1
Bum!
Final dos passos para o número 1
Final dos passos para o número 2
Final dos passos para o número 3
Final dos passos para o número 4
Final dos passos para o número 5
#+end_example

Observando a sequência de impressões, podemos ver como foi o funcionamento da recursão.

Vamos a mais um problema que pode ser descrito de forma recursiva, o cálculo de potência,
$x^n$ com n inteiro positivo. Sabemos que $x^n = x.x^{n-1}$, sendo que $x^0 = 1$.
Logo, temos o seguinte código:

#+begin_SRC julia :eval no-export :exports both
function potencia(x,n)
    if n<= 0
        return 1
    else
        return x * potencia(x, n - 1)
    end
end
#+end_SRC

Vale a pena observar que ao mudar a ordem do if, não há alteração de
funcionalidade.

#+begin_SRC julia :eval no-export :exports both
function potencia(x,n)
    if n>=1
        return x * potencia(x, n - 1)
    else
        return 1
    end
end
#+end_SRC

#+RESULTS:
: potencia (generic function with 1 method)


#+begin_SRC julia :eval no-export :exports both
potencia(2, 3)
#+end_SRC

#+RESULTS:

Vamos ver agora como resolver usando recursão um problema clássico em
computação, fazer com que uma variável, começando no valor 1, seja incrementada,
até o valor n. Ou seja, 1, 2, 3, ..., n.

Nesse caso específico, vamos ver a recursão inicialmente com dois parâmetros,
i e n. Sendo que quando ir chegar a n, acabou. Caso contrário teremos uma chamada
adicional para i + 1. Para ajudar o entendimento, faremos prints do valor de i.


#+begin_SRC julia :eval no-export :exports both
function vaiaten(i, n)
    if i >= n
        println(i)
    else
        print(i, " ")
        vaiaten(i + 1, n)
    end
end
#+end_SRC

Novamente, temos o critério de parada (i >= n) e o passo da recursão.
Logo, usando a função acima, uma repetição de 1 a n pode ser feita com
a chamada.

#+begin_SRC julia :eval no-export :exports both
function laço(n)
    vaiaten(1, n)
end
#+end_SRC

#+RESULTS:
: laço (generic function with 1 method)

#+begin_SRC julia :eval no-export :exports both
laço(10)
#+end_SRC

#+RESULTS:

Para ver o potencial da repetição, vamos ver dois exemplos, um que imprime os quadrados:

#+begin_SRC julia :eval no-export :exports both
function quadrados(i, n)
    if i >= n
        println(i, " ", i * i)
    else
        print(i, " ", i * i)
        quadrados(i + 1, n)
    end
end
quadrados(1, 10)
#+end_SRC

#+RESULTS:
: quadrados (generic function with 1 method)
: 1 12 43 94 165 256 367 498 649 8110 100

e cubos:

#+begin_SRC julia :eval no-export :exports both
function cubos(i, n)
    if i >= n
        println(i, " ", i * i * i)
    else
        println(i, " ", i * i * i)
        cubos(i + 1, n)
    end
end
cubos(1, 10)
#+end_SRC

#+RESULTS:
#+begin_example
cubos (generic function with 1 method)
1 1
2 8
3 27
4 64
5 125
6 216
7 343
8 512
9 729
10 1000
#+end_example

** Aula 07 - Funções que se chamam, algoritmos mais elaborados
:PROPERTIES:
:EXPORT_FILE_NAME: aula_07.pdf
:END:

Nessa aula,  vamos ver  algoritmos um  pouco mais  elaborados. Mas,  sabendo que
vamos usar algo com um maior grau de sofisticação, que tal pensar em testes.

De  uma forma  geral, para  verificar o  funcionamento de  um programa,  podemos
escrever testes que verificam o  funcionamento em algumas situações específicas.
Dado que o primeiro problema que queremos resolver é um algoritmo que encontra o
n-ésimo número de Fibonacci. Por que não começar com testes?

Em uma  busca rápida,  podemos ver que  a sequência de  Fibonacci é  definida da
seguinte forma,  os dois primeiros elementos  $F_1$ e $F_2$ valem  1, em seguida
temos a fórmula  $F_n = F_{n-1} +  F_{n-2}$. Mas, antes de pensar  em resolver o
problema vamos pensar em como testar.

Já  sabemos os  primeiros  valores, além  disso, através  de  uma busca  rápida,
podemos  descobrir alguns  valores  da sequência  como  $F_5 =  5$  e $F_{12}  =
144$. Supondo que a função para o cálculo do n-ésimo número de Fibonacci chamará
fibo(). Podemos escrever o seguinte trecho de código:

#+begin_SRC julia :eval no-export :exports both
function testafibo_versao1()
  if fibo(1) == 1
    println("Deu certo para 1")
  end
  if fibo(2) == 1
    println("Deu certo para 2")
  end
  if fibo(5) == 5
    println("Deu certo para 5")
  end
  if fibo(12) == 144
    println("Deu certo para 12")
  end
  println("Final dos testes")
end
#+end_SRC

A função de testes acima verifica se a função fibo() devolve o resultado correto
para três casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que
pode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com
relação a testes automatizados.

*Se o teste passou, ele deve indicar apenas que deu certo!*

Levando em conta o que foi escrito acima, podemos mudar o nosso teste para:


#+begin_SRC julia :eval no-export :exports both
function testafibo()
  if fibo(1) != 1
    println("Não deu certo para 1")
  end
  if fibo(2) != 1
    println("Não deu certo para 2")
  end
  if fibo(5) != 5
    println("Não eu certo para 5")
  end
  if fibo(12) != 144
    println("Não deu certo para 12")
  end
  println("Final dos testes")
end
#+end_SRC

Agora de posse da nossa função de testes, podemos escrever a nossa função de Fibonacci

#+begin_SRC julia :eval no-export :exports both
function fibo(n)
    if n <= 2
        return 1
    else
        return fibo(n - 1) + fibo(n - 2)
    end
end
fibo(10)
#+end_SRC

#+RESULTS:
: fibo (generic function with 1 method)
: 55

É interessante notar que apesar de ser um dos exemplos clássicos de uso de
recursão, o algoritmo acima é extremamente ineficiente. A razão é simples, cada
vez que é feita a chamada, toda os valores de Fibonacci são recalculados para os
valores de $n$ e $n-1$.

Como Julia é uma linguagem moderna podemos usar o conceito de Memoização (evite
de calcular o que já foi calculado. O Memoize tem que ser instalado no Julia com
os comandos (import Pkg; Pkg.add("Memoize"))

#+begin_SRC julia :eval no-export :exports both
using Memoize
@memoize function fibo(n)
    if n <= 2
        return 1
    else
        return fibo(n - 1) + fibo(n - 2)
    end
end
fibo(10)
#+end_SRC

#+RESULTS:
: fibo (generic function with 1 method)
: 55

As diferenças de tempo das duas versões podem ser verificada com o comando @time.

Vamos ao segundo algoritmo da aula, o MDC (Máximo Divisor Comum). A ideia é usar o
algoritmo de Euclides.


Basicamente ele diz que o MDC de dois números a e b, é igual ao MDC de b e r,
onde $r=a\% b$. Quando esse resto for zero, chegamos a solução, que é b.

Vamos começar com os testes para alguns valores bem conhecidos:

#+begin_SRC julia :eval no-export :exports both
function testaMDC()
    if MDC(3298, 2031)!= 1
        println("deu erro, para 3298 e 2031")
    end
    if MDC(120, 36)!= 12
        println("deu erro, para 120 e 36")
    end
    if MDC(36, 120)!= 12
        println("deu erro, para 36 e 120")
    end
    println("Acabaram os testes")
end
#+end_SRC

#+RESULTS:
: testaMDC (generic function with 1 method)

Vamos pensar na função agora:

#+begin_SRC julia :eval no-export :exports both
function MDC(a, b)
    r = a % b
    if r == 0
        return b
    elseif r == 1
        return 1
    else
        return MDC(b, r)
    end
end
MDC(127,12)
#+end_SRC

#+RESULTS:
: MDC (generic function with 1 method)
: 1

Para terminar a aula, os alunos perguntaram como executar algoritmos usando a
linha de comando.  Isso é relativamente simples, basta usar o editor de texto
(puro) da sua preferência, como o nano, juno, atom, vscode ou outro e salvar um
arquivo com a extensão .jl.

Mas, para que algo seja executado é importante colocar uma chamada ao final. Veja abaixo
um possível arquivo mdc.jl.

#+begin_SRC julia :eval no-export :exports both
function testeMDC()
    if mdc(70, 5) != 5
        println("Não funcionou para 70 e 5")
    end
    if mdc(13, 7) != 1
        println("Não funcionou para 13 e 7")
    end
    if mdc(127, 15) != 1
        println("Não funcionou para 127 e 15")
    end
    if mdc(20, 15) != 5
        println("Não funcionou para 20 e 15")
    end
    if mdc(42, 3) != 3
        println("Não funcionou para 42 e 3")
    end
    if mdc(42, 8) != 2
        println("Não funcionou para 42 e 8")
    end
    println("Final dos testes")
end

function mdc(a, b)
    r = a % b
    if r == 0
        return b
    else
        mdc(b, r)
    end
end

testeMDC()
println("O mdc entre 1227 e 321 é ", mdc(1227, 321))

#+end_SRC

O resultado final será:
#+RESULTS:
: testeMDC (generic function with 1 method)
: mdc (generic function with 1 method)
: Final dos testes
: O mdc entre 1227 e 321 é 3

** Aula 08 - Ainda algoritmos
:PROPERTIES:
:EXPORT_FILE_NAME: aula_08.pdf
:END:

Vamos começar a aula vendo uma forma mais simples de se rodar testes. Nos testes
que vimos até agora sempre havia o teste de uma condição booleana associado a uma
mensagem de erro quando não funcionasse. Mas, observando que a mensagem de erro geralmente
está ligada à condição, por vezes a condição pode ser auto-explicativa.

Logo, uma forma elegante de expressar as condições pode ser útil na escrita dos testes.
Para isso, vamos usar o módulo de testes:


#+begin_SRC julia :eval no-export :exports both
using Test
@testset "Modelo de testes" begin
    @test 2 == 1 + 1
    @test true
    @test !false
end
#+end_SRC

#+RESULTS:
: Test Summary:    | Pass  Total
: Modelo de testes |    3      3
: Test.DefaultTestSet("Modelo de testes", Any[], 3, false)

Claro que o teste dá infomações relevantes quando falha:

#+begin_SRC julia :eval no-export :exports results
using Test
@test 2 + 2 != 4
#+end_SRC

#+RESULTS:
: Test Failed at none:2
:   Expression: 2 + 2 != 4
:    Evaluated: 4 != 4

Agora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a soma
dos dígitos de um número inteiro. Ou seja, pensar em um número dígito à dígito.
Vamos aos testes primeiro:

#+begin_SRC julia :eval no-export :exports results
using Test
@testset "Teste da Soma de Dígitos" begin
    @test somaDig(0) == 0
    @test somaDig(1) == 1
    @test somaDig(100) == 1
    @test somaDig(123) == 6
    @test somaDig(321) == 6
    @test somaDig(99) == 18
end
#+end_SRC



Vamos agora tentar pensar em como "descascar" um número, dado o número 123, uma
forma seria pegar o resto por 10 (ou seja 3) e depois dividir por 10 (ou seja 12),
e assim por diante. Ou seja.

#+begin_SRC julia :eval no-export :exports results
function somaDig(n)
    if n <=0 return 0
    else
        return n % 10 + somaDig(n ÷ 10)
    end
end

println(somaDig(1234))
#+end_SRC

#+RESULTS:
: somaDig (generic function with 1 method)
: 10

Vamos agora a um outro problema clássico, a verificação se um número é ou não é primo.
Na prática para fazer isso, temos a definição, um número $n$ é primo apenas se for
divisível apenas por 1 e por ele mesmo. Ou seja, nenhum número entre 2 e $n - 1$ pode
ser divisor de um número primo.

A forma de se fazer isso é relativamente simples. Vamos pensar em uma função que tenta
dividir um número recursivamente, se conseguir devolve falso, se não conseguir devolve
verdadeiro.

Vamos aos código:

#+begin_SRC julia :eval no-export :exports results
function divide(n, i)
    if n % i == 0
        return false
    elseif i == n - 1
        return true
    else
        return divide(n, i + 1)
    end
end
#+end_SRC

Que pode ser chamada por:

#+begin_SRC julia :eval no-export :exports results
function éPrimo(n)
    return divide(n, 2)
end
#+end_SRC

Mais um exemplo, o método de Newton para o cálculo de raiz quadrada. Para achar
a raiz de $x$, a partir de um chute inicial (por exemplos $y= x /2$), chegamos a um
novo chute que é a média de $y$ e $x/y$.

Mas, sim, vamos começar com os testes:

#+begin_SRC julia :eval no-export :exports results
using Test
function quaseIgual(a, b)
    if abs(a - b) <= 1e-20
        return true
    else
        return false
    end
end


@testset "Teste da raiz pelo método de Newton" begin
    @test quaseIgual(3.0, raiz(3.0 * 3.0))
    @test quaseIgual(33.7, raiz(33.7 * 33.7))
    @test quaseIgual(223.7, raiz(223.7 * 223.7))
    @test quaseIgual(0.7, raiz(0.7 * 0.7))
    @test quaseIgual(1.0, raiz(1.0 * 1.0))
end

#+end_SRC
Note que como estamos comparando números em ponto flutuante, não usamos a
comparação exata.

A solução final é:

#+begin_SRC julia :eval no-export :exports results
function newton(c, n)
    q = n / c
    if quaseIgual(q, c)
        return q
    else
        return newton( (c + q) / 2.0, n)
    end
end


function raiz(n)
    a =  newton(n / 2.0, n)
    println("a raiz de ", n, " é ", a)
    return a
end
#+end_SRC

*** Funções caóticas

Vamos brincar um pouco agora com funções caóticas :), isso é, funções, que
conforme o comportamento de uma constante $k$, apresentam resultados que podem
convergir ou não. Isso é, a cada passo, quero saber o valor do próximo ponto
aplicando a função novamente, isso é:
\[x_1 = f(x_0), x_2 = f(x_1), \ldots, x_n  = f(x_{n - 1})\]

A função $f$ é extremamente simples: $x_{i + 1}=x_i * (1 -  x_i) * k$.

Implemente a função e imprima os 30 primeiros resultados.
Comece com um valor de $x$ entre 0 e 1, como 0.2. Use constantes $k = 2.1, 2.5, 2.8$ e $3.1$
o que ocorre com $k = 3.7$?

Entregue o código e um pequeno relatório sobre o que acontece.
** Aula 09 - Laços
:PROPERTIES:
:EXPORT_FILE_NAME: aula_09.pdf
:END:

Vamos começar calculando os $n$ primeiros termos da soma harmônica generalizada:
$\sum_{i=1}^{n} \frac{1}{i^2}$.

#+begin_SRC julia :eval no-export :exports both
function somaH(i, n)
    if i >= n
        return 1 / (i * i)
    else
        return 1 / (i * i) + somaH(i + 1, n)
    end
end
somaH(1, 10)
#+end_SRC

#+RESULTS:
: somaH (generic function with 1 method)
: 1.5497677311665408

Mas, vamos ver um outro comando, o while, esse comando é uma outra forma de se
fazer um laço, ou repetição controlada. A sintaxe é:

#+begin_src
while condição
   comandos
end
#+end_src

Ou seja, enquanto a condição for verdadeira, os comandos serão executados.  Com
um exemplo é mais fácil de entender:

#+begin_SRC julia :eval no-export :exports both
function conta()
    i = 0
    while i < 5
        println(i)
        i = i + 1
    end
    println("Fim")
end
conta()
#+end_SRC

#+RESULTS:
: conta (generic function with 1 method)
: 0
: 1
: 2
: 3
: 4
: Fim

Como fazer a soma harmônica usando um while? Basta fazer uma que a repetição
ocorra $n$ vezes, como abaixo:

#+begin_SRC julia :eval no-export :exports both
function serieH(n)
    i = 1
    soma = 0
    while i <= n
        soma = 1 / (i * i) + soma
        i = i + 1
    end
    return soma
end
serieH(100)
#+end_SRC

#+RESULTS:
: serieH (generic function with 1 method)
: 1.6349839001848923

Uma variante possível é começar a soma, pelo último elemento ou seja $\frac{1}{n^2}$ como
abaixo:

#+begin_SRC julia :eval no-export :exports both
function soma(n)
    i = n
    soma = 0
    while i >= 1
        soma = soma + 1 / (i * i)
        i = i - 1
    end
    return soma
end
soma(100)
#+end_SRC

#+RESULTS:
: soma (generic function with 1 method)
: 1.634983900184893

Pode se notar que apesar dos resultados serem bem próximos, há um erro nas
últimas casas decimais, as menos significativas. Logo, sim, apesar dos
algoritmos serem exatamente iguais, há uma perda maior de precisão quando se
começa somando os número maiores.

Um exercício interessante é calcular o valor da série harmônica alternada, ou
seja: $\sum_{i=1}^{n} \frac{-1^{i + 1}}{i}$, essa série converge para $\ln 2$.

#+begin_SRC julia :eval no-export :exports both
using Test
erro = 1e-4

function quaseIgual(a, b)
    if abs(a - b) < erro
        return true
    end
    return false
end


function harmonicaAlternada()
    soma = 0.0
    i = 1
    sinal = 1
    while 1 / i >= erro
        soma = soma + sinal * 1 / i
         sinal = sinal * -1
        i = i + 1
    end
    return soma
end

println(harmonicaAlternada(), " e ", log(2))
@testset "Teste Único" begin
    @test quaseIgual(harmonicaAlternada(), log(2))
end
#+end_SRC

#+RESULTS:
: 0.0001
: quaseIgual (generic function with 1 method)
: harmonicaAlternada (generic function with 1 method)
: 0.6930971830599583 e 0.6931471805599453
: Test Summary: | Pass  Total
: Teste Único   |    1      1
: Test.DefaultTestSet("Teste Único", Any[], 1, false)


Vamos ver um outro problema a conversão
de base, começando com a base binária para a decimal. Por exemplo, o número 1011
equivale a $1.2^3 + 0.2^2 + 1.2^1 + 1.2^0$ ou seja $8 + 0 + 4 + 1 = 13$

Primeiro vamos ver os testes:

#+begin_SRC julia :eval no-export :exports both
using Test

@testset "Teste de binário para decimal" begin
    @test bintodec(0) == 0
    @test bintodec(1) == 1
    @test bintodec(1101) == 13
    @test bintodec(11) == 3
    @test bintodec(10) == 2
end
#+end_SRC

Em seguida o código:


#+begin_SRC julia :eval no-export :exports both
function bintodec(b)
    pot = 1
    soma = 0
    while b > 0
        dig = b % 10
        b = b ÷ 10
        soma = soma + dig * pot
        pot = pot * 2
    end
    return soma
end
#+end_SRC

Da mesma forma, podemos ver como transformar um número decimal em binário,
seguindo a mesma lógica, usando os restos por 2 e em seguida dividindo por 2.
Mais uma vez, começamos com os testes, agora usando as duas funções.

#+begin_SRC julia :eval no-export :exports both
using Test

include("bintodec.jl")

@testset "Teste de binário para decimal" begin
    @test bintodec(0) == 0
    @test bintodec(1) == 1
    @test bintodec(1101) == 13
    @test bintodec(11) == 3
    @test bintodec(10) == 2

    @test dectobi(0) == 0
    @test dectobi(1) == 1
    @test dectobi(13) == 1101
    @test dectobi(3) == 11
    @test dectobi(2) == 10

    @test bintodec(dectobi(1234)) == 1234
    @test bintodec(dectobi(123423)) == 123423
    @test bintodec(dectobi(12343)) == 12343

end

#+end_SRC

Note que é possível usar uma função para testar a outra. Segue o algoritmo de conversão de
decimal para binário.

#+begin_SRC julia :eval no-export :exports both
function dectobi(d)
    pot = 1
    soma = 0
    while d > 0
        dig = d % 2
        d = d ÷ 2
        soma = soma + dig * pot
        pot = pot * 10
    end
    return soma
end
#+end_SRC

** Aula 10 - Blocos de código e escopo
:PROPERTIES:
:EXPORT_FILE_NAME: aula_10.pdf
:END:

*** Reaproveitando código

Para começar, vamos revisitar duas funções já vistas, agora escritas com o while:

#+begin_SRC julia :eval no-export :exports both :tangle src/funct.jl
function fatorial(n)
    fat = 1
    while n > 0
        fat = fat * n
        n = n - 1
    end
    return fat
end

function pot(x, n)
    res = 1
    while n > 0
        res = res * x
        n = n - 1
    end
    return res
end
#+end_SRC

#+RESULTS:
: fatorial (generic function with 1 method)
: pot (generic function with 1 method)

Para lembrar segue a versão recursiva abaixo:

#+begin_SRC julia :eval no-export :exports results
function fatorialr(n)
    if n <= 0
        return 1
    end
    return n * fatorialr(n - 1)
end

function potr(x, n)
    if n <= 0
        return 1
    end
    return x * potr(x, n - 1)
end
#+end_SRC

Para  poder usar  essas funções  em outros  programas, basta  incluir o  nome do
arquivo  onde elas  estiverem, por  exemplo,  funct.jl.  Pode  ser inclusive  no
arquivo com os testes

 #+begin_SRC julia :eval no-export :exports both
using Test
include("src/funct.jl")

@testset "Teste Fatorial" begin
    @test fatorial(0) == 1
    @test fatorial(1) == 1
    @test fatorial(5) == 120
    @test fatorial(3) == 6
end

@testset "Teste Potência" begin
    @test pot(1.0, 0) == 1
    @test pot(2.0, 3) == 8.0
    @test pot(8.0, 2) == 64.0
end
 #+end_SRC

 #+RESULTS:
 : pot (generic function with 1 method)
 : Test Summary:  | Pass  Total
 : Teste Fatorial |    4      4
 : Test.DefaultTestSet("Teste Fatorial", Any[], 4, false, false)
 : Test Summary:  | Pass  Total
 : Teste Potência |    3      3
 : Test.DefaultTestSet("Teste Potência", Any[], 3, false, false)


Isso inclusive nos ajuda no que se refere aos testes automatizados, pois o
arquivo com os testes automatizados pode ser executado de forma independente.

Os testes de potência e fatorial também podem ser independentes!

Agora que temos as funções de cálculo de potência e de fatorial, podemos usá-las
para cálculos mais sofisticados como o de cosseno, usando séries de Taylor: \[
\mbox{cos}(x) = \sum_{n = 0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} \], sendo que
o valor de $x$ é dado em radianos.

#+begin_SRC julia :eval no-export :exports both
include("funct.jl")
function cosseno(x)
  Erro = 1f-7
  série = 0
  termo = 1
  i = 0
  while i < 13   # mas poderiamos olhar também o erro como em abs(termo > Erro)
     série = série + termo
     i = i + 1
     termo = potencia(-1, i) * potencia(x, 2 * i) / fat(2 * i)
  end
  série = série + termo
  return série
end
#+end_SRC

Mas, podemos melhorar a nossa função de cálculo de cosseno observando que
dá para a partir do termo anterior, chegar ao próximo termo.


#+begin_SRC julia :eval no-export :exports both
function cosseno2(x)
    soma = 0.0
    i = 0
    termo = 1.0
    while i <= 20
        soma = soma + termo
        termo = (-1 * termo * x * x) / ((2*i + 1) * (2*i + 2))
        i = i + 1
    end
    return soma
end
#+end_SRC

*** Blocos e escopo

Agora uma discussão sobre uma dúvida que apareceu durante uma aula, a identação. Isso
é o recuo que fazemos para delimitar blocos de código em Julia. Vamos ver um exemplo:

#+begin_SRC julia :eval no-export :exports both
function matematica()
   i = 999
   while i < 1023
       if i % 3 == 0
           print(i, " é divisível por três ")
           soma = 0
           aux = i
           while aux > 0
               soma = soma + aux % 10
               aux = div(aux, 10)
           end
           if soma % 3 == 0
               println(" e a soma dos seus dígitos também")
           else
               println("Deu ruim, resultado não esperado para: ", i)
               break # sim esse break é justificado :)
           end
       end
       i = i + 1
   end
end
matematica()
#+end_SRC

 Aproveitei para introduzir um novo comando, o break, que serve para sair
 do laço em questão.


#+RESULTS:
: matematica (generic function with 1 method)
: 999 é divisível por três  e a soma dos seus dígitos também
: 1002 é divisível por três  e a soma dos seus dígitos também
: 1005 é divisível por três  e a soma dos seus dígitos também
: 1008 é divisível por três  e a soma dos seus dígitos também
: 1011 é divisível por três  e a soma dos seus dígitos também
: 1014 é divisível por três  e a soma dos seus dígitos também
: 1017 é divisível por três  e a soma dos seus dígitos também
: 1020 é divisível por três  e a soma dos seus dígitos também

No código acima, vemos, com a ajuda da identação os diferentes blocos. Por
exemplo, observando o bloco onde é feita a soma dos dígitos, pode-se pensar
em criar uma função para ele. Como abaixo:

#+begin_SRC julia :eval no-export :exports both
function somaDigitos(n)
    soma = 0
    while n > 0
        soma = soma + n % 10
        n = n ÷ 10
    end
    return soma
end

function matematica()
   i = 999
   while i < 1023
       if i % 3 == 0
           print(i, " é divisível por três ")
           soma = somaDigitos(i)
           if soma % 3 == 0
               println(" e a soma dos seus dígitos também")
           else
               println("Deu ruim, resultado não esperado para: ", i)
               break # sim esse break é justificado :)
           end
       end
       i = i + 1
   end
end
matematica()
#+end_SRC

#+RESULTS:
#+begin_example
somaDigitos (generic function with 1 method)
matematica (generic function with 1 method)
999 é divisível por três  e a soma dos seus dígitos também
1002 é divisível por três  e a soma dos seus dígitos também
1005 é divisível por três  e a soma dos seus dígitos também
1008 é divisível por três  e a soma dos seus dígitos também
1011 é divisível por três  e a soma dos seus dígitos também
1014 é divisível por três  e a soma dos seus dígitos também
1017 é divisível por três  e a soma dos seus dígitos também
1020 é divisível por três  e a soma dos seus dígitos também
#+end_example

Mas, diferente de Python, a identação não serve para definir os blocos, mas
sim palavras reservadas como function, while ou mesmo begin.

Além dos blocos, também é interessante entender o conceito de escopo, vamos a um exemplo:

#+begin_SRC julia :eval no-export :exports both
function valeum(a)
   println("Dentro da função valeum(): a valia: ", a)
   a = 1
   println("agora a vale ", a)
end
function avaleum()
   # não imprime a aqui, pois daria erro
   a = 1
   println("Dentro da função avaleum(), a vale: ", a)
end

function vamosver()
   a = 3
   println("a vale: ", a)
   begin
     println("Modifiquei a em um bloco")
     a = 2
     println("a vale: ", a)
   end
   println("O a vale, fora do bloco ", a)
   valeum(a)
   println("a vale: ", a)
   avaleum()
   println("a vale: ", a)
end
vamosver()
#+end_SRC

#+RESULTS:
#+begin_example
valeum (generic function with 1 method)
avaleum (generic function with 1 method)
vamosver (generic function with 1 method)
a vale: 3
Modifiquei a em um bloco
a vale: 2
O a vale, fora do bloco 2
a valia: 2
agora a vale 1
a vale: 2
a vale: 1
a vale: 2
#+end_example



 No código acima, podemos ver duas coisas importantes, o escopo (valor de uma variável
 vai além dos blocos, pois ao modificar dentro de um bloco, modificamos a variável original.
 Por outro lado, o escopo é independente conforme a função.

Ao chamar uma função com uma variável é passada uma cópia da variável, que é no início da
função igual ao valor original.

De uma forma geral, as variáveis declaradas em contextos mais gerais, podem ser usadas
em contexto mais restritos, mas nunca ao contrário. Na seguinte função, como $t$ é declarada
dentro do bloco, ela não existe fora dele:

#+begin_SRC julia :eval no-export :exports results
function laço()
    i = 10
    while i > 0
        t = 100
        i = i - 1
    end
    print(t)  # vai dar erro!
end
#+end_SRC

Como pode-se imaginar, é muito comum ter comandos que repetem $n$ vezes,
ou que fazem que uma variável vá de 1 até $n$. Uma forma reduzida de se
fazer isso é por meio do comando for.

#+begin_SRC julia :eval no-export :exports results
for i in 1:10
    println(i)
end
#+end_SRC

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
#+end_example

 Um exercício para terminar.
 Dado um número $n$ sabe-se que $n^3$ pode ser representado pela
 soma de $n$ números ímpares consecutivos, encontre esses valores para $n$ de 1 a 10.

 #+begin_SRC julia :eval no-export :exports both
function somanímpares(x, n)
    soma = 0
    for i in 1:n
        soma = soma + x
        x = x + 2
    end
    return soma
end

function achaoprimeiro(n)
    cubo = n^3
    impar = 1
    while somanímpares(impar, n) < cubo
        impar = impar + 2
    end
    return impar
end

function imprime()
    for i in 1:20
        primeiro = achaoprimeiro(i)
        print(i^3, " = ")
        for j in 1:i - 1
            print(primeiro, " + ")
            primeiro = primeiro + 2
        end
        println(primeiro)
    end
end

imprime()
 #+end_SRC
** Aula 11 - Entrada de Dados e Listas
:PROPERTIES:
:EXPORT_FILE_NAME: aula_11.pdf
:END:

*** Entrada de dados e o começo de listas
Nessa aula, temos dois tópicos principais, como fazer a entrada de dados,
através de comandos de entrada e com argumentos na linha de comando. Além disso
também veremos como tratar de um tipo especial de variável, onde é possível,
guardar mais de um valor.

**** O comando input
Quando queremos inserir dados, em Julia, basta colocar dados. Mas, como podemos
fazer para entrar dados em um programa comum?

Para isso temos o comando readline(), que interrompe a execução do programa e
espera pela entrada de uma String, o que ocorre quando a tecla "enter" é
pressionada.

 #+begin_SRC julia :eval no-export :exports both
println("Digite o seu nome")
resposta = readline()
println("O seu nome é: ", resposta)
 #+end_SRC

 #+RESULTS:
 : Digite o seu nome
 : "Alfredo"
 : O seu nome é: Alfredo

Como o readline() lê Strings, se quisermos ler números, é
necessário usar o comando parse.

#+begin_SRC julia :eval no-export :exports both
println("Digite um inteiro")
valor = parse(Int64, readline())
println("O numero digitado foi ", valor)
#+end_SRC

#+RESULTS:
: Digite um inteiro
: 64
: O numero digitado foi 64

Sabendo ler números do teclado, vamos a um exercício simples, ler uma
sequência de números inteiros terminada por zero e devolver a sua soma.

#+begin_SRC julia :eval no-export :exports both
function somaVarios()
    soma = 0.0
    println("Digite um número")
    n = parse(Float64, readline())
    while  n!=0
        soma = soma + n
        println("Digite um número")
        n = parse(Float64, readline())
    end
    println("A soma é: ", soma)
end
#+end_SRC

**** Lendo através da linha de comando
 A outra forma de ler comandos é através da constante ARGS que é
preparada na chamada de um programa. Para entender melhor isso, vamos
ver o seguinte programa.

 #+begin_SRC julia :eval no-export :exports both
 println(ARGS)
 #+end_SRC

Se a linha acima está no arquivo args.jl, ao chamar julia args.jl com diversos
parâmetros, teremos diversos resultados diferentes.

Por exemplo ao chamar:

julia args.jl 1 2 3 abc

Teremos como resposta

#+begin_SRC julia :eval no-export :exports both
["1", "2", "3", "abc"]
#+end_SRC

Vamos analisar um pouco melhor essa resposta observando que cada
parâmetro está em uma posição.

#+begin_SRC julia :eval no-export :exports both
tam = length(ARGS)
println("O tamanho dos argumentos é: ", tam)
for i in 1:tam
    println(ARGS[i])
end
#+end_SRC

 Olhando o código acima, podemos ver que a função length() devolve
o número de argumentos, ou seja, o tamanho da lista ARGS. Além disso
com os colchetes é possível acessar a cada posição da lista de forma
individual.


O exemplo abaixo  soma os parâmetros inteiros dados como argumentos. Ele
também ilustra uma boa prática que é, sempre colocar o código em módulos,
no caso abaixo em funções:

 #+begin_SRC julia :eval no-export :exports both
 function SomaEntrada()
     tam = length(ARGS)
     s = 0
     i = 1
     while i <= tam
         valor = parse(Int, ARGS[i])
         println(valor)
         s = s + valor
         i = i + 1
     end
     println("A soma foi: ", s)
 end
 SomaEntrada()

 #+end_SRC

A flexibilidade que temos ao usar listas é enorme! Por isso,
listas ou vetores, merecem um tópico próprio.

**** Listas

Vamos primeiro brincar um pouco no console.

#+begin_SRC julia :eval no-export :exports both
vetor = [1, 2, 3]
println(vetor[1])
println(length(vetor))
vetor[2] = vetor[2] + 1
vetor[1] = 2 * vetor[3]
println(vetor)
#+end_SRC

Como disse antes, o for foi feito para manipular vetores,
vamos ver umas funções, a primeira que imprime os elementos de um vetor
um por linha.

 #+begin_SRC julia :eval no-export :exports both
 function imprimeVetor(v)
     for el in v
         println(el)
     end
 end
 #+end_SRC

Isso também pode ser feito através dos índices do vetor:

 #+begin_SRC julia :eval no-export :exports both
 function imprimeVetor(v)
     for i in 1:lenght(v)
         println(v[i])
     end
 end
 #+end_SRC

Como cada posição é independente, podemos calcular a soma dos
elementos ímpares de um vetor

#+begin_SRC julia :eval no-export :exports both
function somaImpVetor(v)
         soma = 0
         for i in 1:length(v)
           if v[i] % 2 == 1
             soma = soma + v[i]
           end
         end
         return soma
       end
#+end_SRC

Para terminar, vamos fazer uma função onde dado um vetor de inteiros
de tamanho $n$, verifica se esse vetor é uma permutação dos números de
1 a $n$. Para isso, veremos se cada número de 1 a $n$ está no vetor.

Mas, sem esquecer dos testes:

#+begin_SRC julia :eval no-export :exports both
@testset "Verifica Permutação" begin
    @test permuta([1,2,3])
    @test permuta([3, 2, 1])
    @test permuta([1])
    @test permuta([2, 1])
    @test permuta([4, 2, 3, 1])
    @test !permuta([1, 1])
    @test !permuta([1, 3])
    @test permuta([])
end
#+end_SRC

e o código:

#+begin_SRC julia :eval no-export :exports both
function permuta(v)
   tam = length(v)
   for i in 1:tam
      if  !(i in v)
         return false
      end
   end
   return true
end
#+end_SRC

Foi usado o comando in de Julia que verifica se um elemento está no vetor.


** Aula 12 - Introdução aos Vetores
:PROPERTIES:
:EXPORT_FILE_NAME: aula_12.pdf
:END:

*** Conhecendo melhor os vetores
**** Passar vetores como parâmetro é diferente
Assim  como já  passamos  variáveis  normais, ou  escalares,  como parâmetro  de
funções, também  podemos passar  vetores. Mas, é  importante ressaltar  que isso
ocorre de forma distinta, isso é, os vetores são passados por referência.

Vamos a  uma analogia, quando  se passa uma  variável escalar, como  parâmetro a
função recebe uma cópia  dela. Já para um vetor, o que se  recebe é uma cópia do
endereço dele.  Em algumas linguages como  C, isso é completamente  explícito, e
essa referência é denominada ponteiro.

#+begin_SRC julia :eval no-export :exports both
function mudavalores(x, v)
   println("x = ", x, " e v = ", v)
   x = 1
   v[1] = 1
   println("x = ", x, " e v = ", v)
end
function vesemuda()
   x = 0
   v = [2, 3, 4]
   println("x = ", x, " e v = ", v)
   println("Antes da mudavalores")
   mudavalores(x, v)
   println("Depois da mudavalores")
   println("x = ", x, " e v = ", v)
end
vesemuda()
#+end_SRC


Ao executar a função vesemuda(), podemos ver que como esperado para
a variável escalar, no escopo da função a cópia foi alterada, sem
mudança na variável $x$ original.

#+RESULTS:
: mudavalores (generic function with 1 method)
: vesemuda (generic function with 1 method)
: x = 0 e v = [2, 3, 4]
: Antes da mudavalores
: x = 0 e v = [2, 3, 4]
: x = 1 e v = [1, 3, 4]
: Depois da mudavalores
: x = 0 e v = [1, 3, 4]


 Por outro lado, para o vetor, como tínhamos uma cópia do endereço,
mudar sua primeira posição, fez com que o vetor original fosse alterado.
Mas, alterar a cópia do endereço, não muda o endereço final, como pode
se ver abaixo:

 #+begin_SRC julia :eval no-export :exports both
function novovetor(v)
   println("O vetor era = ", v)
   v = ["a", "b", "c"]
   println("O vetor ficou sendo = ", v)
end
function vesemuda2()
   v = [2, 3, 4]
   println("v = ", v)
   println("Antes de novovetor")
   novovetor(v)
   println("Depois de novovetor")
   println("v = ", v)
end
vesemuda2()
#+end_SRC

#+RESULTS:
: novovetor (generic function with 1 method)
: vesemuda2 (generic function with 1 method)
: v = [2, 3, 4]
: Antes de novovetor
: O vetor era = [2, 3, 4]
: O vetor ficou sendo = ["a", "b", "c"]
: Depois de novovetor
: v = [2, 3, 4]

**** Vamos continuar vendo como manipular vetores

Para isso, vamos precisar conhecer algo de Julia, que vai
nos ajudar. Por enquanto já sabemos como acessar posições específicas
de um vetor.

Mas, vamos precisar de alguns comandos adicionais para fazer
os próximos exercícios. São eles: criar um vetor vazio, adicionar um
ou mais elementos ao final do vetor, e criar um vetor de um tamanho
definido.

#+begin_SRC julia :eval no-export :exports both
v = [] # define um vetor vazio
push!(v, 1)  # adiciona um primeiro elemento 1 ao vetor
push!(v, 2, 3) # adiciona os elementos 2 e 3 ao vetor
zeros(Int, 3) # cria um vetor para guardar inteiros com 3 posições
zeros(Float, 10) # cria um vetor para guardar floats com 10 posições
#+end_SRC

#+RESULTS:
#+begin_example
0-element Array{Any,1}
1-element Array{Any,1}:
 1
3-element Array{Any,1}:
 1
 2
 3
3-element Array{Int64,1}:
 0
 0
 0
#+end_example

Nós já vimos que usualmente vetores em Julia podem guardar qualquer
tipo de variável, mas já é bom saber que ao usarmos um vetor com
tipo pré-identificado, isso é, por exemplo, só de inteiros. Seu
uso fica mais eficiente.

Vamos agora exercitar um pouco o uso de vetores:

Faça uma função inverte que dado um vetor, devolve esse vetor com os valores
invertidos (isso é, quem estava na primeira posição vai para a última e assim
por diante).

#+begin_SRC julia :eval no-export :exports both
function inverte(v)
    tamanho = length(v)
    x = []
    for i in tamanho:-1:1
        push!(x, v[i])
    end
    println(x)
    return x
end
#+end_SRC

Seu funcionamento pode ser verificado com os seguintes testes:

#+begin_SRC julia :eval no-export :exports results
using Test
@testset "Teste do Inverte" begin
    @test inverte([]) == []
    @test inverte([12]) == [12]
    @test inverte([1, 2, 3]) == [3, 2, 1]
    @test inverte([100, 10, 1]) == [1, 10, 100]
end
#+end_SRC

Faça uma função que recebe um vetor de inteiros e devolve um vetor
apenas com os números ímpares do vetor original

#+begin_SRC julia :eval no-export :exports both
using Test
function impares(v)
    tamanho = length(v)
    x = []
    for el in v
        if el % 2 != 0
            push!(x, el)
        end
    end
    println(x)
    return x
end

@testset "Teste dos Ímpares" begin
    @test impares([]) == []
    @test impares([12]) == []
    @test impares([1, 2, 3]) == [1, 3]
    @test impares([100, 10, 1]) == [1]
end
#+end_SRC

 Dado um vetor de números inteiros, faça uma função que devolve um vetor que
 corresponde a uma leitura desse vetor, conforme o número de elementos. Ou seja,
 dado o vetor [1, 1, 1, 4, 10, 10, 4] o vetor de saída dever ser [3, 1, 1, 4, 2,
 10, 1, 4] ou seja, três "1", um "4", dois "10" e um "quatro".

#+begin_SRC julia :eval no-export :exports both
using Test

function leitura(v)
    tam = length(v)
    x = []
    i = 1
    while i <= tam
        el = v[i]
        qtd = 1
        while i + 1 <= tam  && v[i + 1] == el
            qtd = qtd + 1
            i = i + 1
        end
        push!(x, qtd)
        push!(x, el)
        i = i + 1
    end
    return x
end

@testset "Teste de leitura" begin
    @test leitura([]) == []
    @test leitura([12]) == [1, 12]
    @test leitura([1, 2, 3]) == [1, 1, 1, 2, 1,  3]
    @test leitura([10, 10, 1]) == [2, 10, 1, 1]
    @test leitura([1, 1, 1, 4, 10, 10, 4]) == [3, 1, 1, 4, 2, 10, 1, 4]
    @test leitura([1, 1, 1, 1, 4, 10, 10, 4]) == [4, 1, 1, 4, 2, 10, 1, 4]
end
#+end_SRC

#+RESULTS:
: leitura (generic function with 1 method)
: Test Summary:    | Pass  Total
: Teste de leitura |    6      6
: Test.DefaultTestSet("Teste de leitura", Any[], 6, false)

Sabendo que o comando rand(1:n), vai devolver um número entre 1 e n.
Escreva uma função que dado um inteiro n, devolve um vetor com uma
permutação aleatória de 1 a n.

#+begin_SRC julia :eval no-export :exports both
function permuta(n)
    v = []
    jásaiu = zeros(Int64, n)
    i = 0
    j = 0
    while i < n
        sorteio = rand(1:n)
        if jásaiu[sorteio] == 0
            jásaiu[sorteio] = 1  # marca que o número no índice sorteio saiu
            push!(v, sorteio)
            i = i + 1
        end
        j = j + 1
    end
    println("Para preencher o vetor foram necessários ", j, " sorteios)
    return v
end
permuta(100)

#+end_SRC

#+RESULTS:

#+begin_SRC julia :eval no-export :exports results
function permuta(n)
    v = []
    jásaiu = zeros(Int64, n)
    i = 0
    j = 0
    while i < n
        sorteio = rand(1:n)
        if jásaiu[sorteio] == 0
            jásaiu[sorteio] = 1  # marca que o número no índice sorteio saiu
            push!(v, sorteio)
            i = i + 1
        end
        j = j + 1
    end
    println("Para preencher o vetor foram necessários ", j, " sorteios")
    return v
end
permuta(10)
#+end_SRC

#+RESULTS:
#+begin_example
permuta (generic function with 1 method)
Para preencher o vetor foram necessários 17 sorteios
10-element Array{Any,1}:
  7
  1
  8
  9
 10
  2
  6
  5
  3
  4
#+end_example

Voltando ao exercício da anterior vamos pensar para que a criação
do vetor seja mais eficiente. Uma forma de se fazer isso é guardar
um vetor de números ainda não sorteados.

** Aula 13 - Mais sobre Vetores
:PROPERTIES:
:EXPORT_FILE_NAME: aula_13.pdf
:END:

*** Voltando a vetores

Vamos agora voltar à parte algorítmica, com o seguinte problema.
Subsequência de soma máxima. Dado um vetor de inteiros, devolver a
soma de elementos consecutivos que seja máxima.

Vamos começar pelos testes.

#+begin_SRC julia :eval no-export :exports both
using Test
@testset "Teste SubSequencia" begin
  @test somasub([]) == 0
  @test somasub([1, 2, 3]) == 6
  @test somasub[-1, -2, -3]) == -1
  @test somasub([10, 5, -17, 20, 5, -1, 3, -30, 10]) == 27
  @test somasub([31, -41, 59, 26, -53, 58, 97, -93, -23, 84] == 187
end
#+end_SRC

 Vamos começar com a solução de força bruta, isso é, calcular a soma
de todas a sub-sequências, procurando pela máxima.

 #+begin_SRC julia :eval no-export :exports both
 function somaParcial(i, f, v)
    if i > f
        return 0
    else
        soma = 0
        while i <= f
            soma = soma + v[i]
            i = i + 1
        end
        return soma
    end
end

function somasub(v)
    tam = length(v)
    if tam == 0
        return 0
    end
    somaMax = v[1]
    for i in 1:tam
        for f in i:tam
            soma = somaParcialr(i, f, v)
            if soma > somaMax
                somaMax = soma
            end
        end
    end
    return somaMax
end
 #+end_SRC

Notem que também seria possível ter uma versão recursiva do
algoritmo de soma.

#+begin_SRC julia :eval no-export :exports results
function somaParcialr(i, f, v)
    if i > f
        return 0
    else
        return v[i] + somaParcialr(i + 1, f, v)
    end
end
#+end_SRC

Agora vamos a um algoritmo mais elaborado (Jay-Kadane). Ele é
bem rápido (passa apenas uma vez pelo vetor), mas um pouco
mais difícil de entender.

#+begin_SRC julia :eval no-export :exports both
# Sugerido pelo Luiz Fernando Rabelo
function get_greatest_subsequence_sum_kadane(vector)
    if length(vector) == 0
        return 0
    end
    greatest_sum = -Inf64  # menor número representável
    current_sum = 0
    for i in 1:length(vector)
        current_sum += vector[i]
        if current_sum > greatest_sum
            greatest_sum = current_sum
        end
        if current_sum < 0
            current_sum = 0
        end
    end
    return greatest_sum
end
#+end_SRC

Abaixo temos uma função, onde dados dois vetores u e v de tamanho igual,
devolve o seu produto escalar.

#+begin_SRC julia :eval no-export :exports both
function produto(a, b)
    if length(a) != length(b)
        return    # a função não devolve nada nesse caso
    end
    tam = length(a)
    soma = 0
    for i in 1:tam
        soma = soma + a[i] * b[i]
    end
    return soma
end
#+end_SRC


** Aula 14 - Simulado de prova
:PROPERTIES:
:EXPORT_FILE_NAME: aula_14.pdf
:END:

*** Prova do BCC  2019 (traduzida de C para Julia)
**** Questão 1 (1.5 pontos)
Dado o seu NUSP qual é a saída do programa abaixo?
#+begin_SRC julia :eval no-export :exports both
function misterio(n)
   b = n
   c = -1
   while b > 0
      a = b % 10
      b = b ÷ 10
      if a > c
         c = a
      end
      x = float(b / 10)
      println("n = ", n, "  a = ", a, "  b = ", b, "  c = ", c, "  x = ", x)
   end
   println("c = ", c, " n/100 ", n/100)
end
#+end_SRC

**** Questão 2 (2.5 pontos)
Um número inteiro $n > 0$ é perfeito se ele for igual à soma de seus divisores
positivos diferentes de $n$.

Exemplo:
-  6 é perfeito, pois 6 = 1 + 2 + 3;
-  28 é perfeito, pois 28 = 1 + 2 + 4 + 7 + 14.

Faça uma função que recebe um número inteiro $n > 0$ e decide se $n$ é  perfeito.

**** Questão 3 (2.5 pontos)
Dado um vetor com $n$ números inteiros, desejamos encontrar o comprimento
de um maior segmento crescente da sequência.
Exemplo:
- para o vetor v = [4, 7, 2, 4, 7, -2, 5, 8, 1, 17]
um maior segmento crescente tem comprimento 3.
- para o vetor v = [10, 10, 5, 3, 2]
um maior segmento crescente tem comprimento 1.
- para o vetor v = [2, 7, 5, 6, 8, 13, 9, 11, 2, 5, 7, 4, 13]
um segmento crescente de comprimento máximo tem tamanho 4.

**** Questão 4 (3.5 pontos)

Dizemos que um número inteiro $n$ é 3-alternante se, quando $n$ é escrito
 na base 3, alterna números pares e ímpares.
Exemplo:
- 151 é 3-alternante, pois 151 escrito na base 3 é 12121 que alterna pares e ímpares.
- 145 é 3-alternante, pois escrito na base 3 é 12101, que alterna pares e ímpares.
- 48 é 3-alternante, pois escrito na base 3 é 1210.
- 37 não é 3-alternante, pois escrito na base 3 é 1101.
- 2 é 3-alternante, pois se escreve 2 na base 3.
Faça uma função que lê um inteiro $n \geq 0$ e verifica se n é 3-alternante.

*** Prova do IF de 2018
**** Questão 1
Escreva um programa onde dado um inteiro positivo $n$ imprime os $n$ primeiros
termos da sequência abaixo:
\[ A(0) = 0, A(1) = 1, \mbox{ e } A(n) = A(n-1) - A(n-2)\]

**** Questão 2
Escreva um programa que calcula a soma dos $k$ primeiros termos da série de Taylor
da função:
\[f(x) = e^{-x^2} = 1 - x^2 + \frac{x^4}{2!} - \frac{x^6}{3!} + \ldots \]

**** Questão 3
Faça uma função que mostra que, dados três números primos, $p_1, p_2$ e $p_3$
se $p_1 p_2, p_1 p_3$ e $p_2 p_3$ são números de Poulet $p_1 p_2 p_3$ também é.

Um número $n$ é de Poulet se
\[ 2^{n - 1} - 1 \% n == 0 \]

Mais informações em: https://en.wikipedia.org/wiki/Super-Poulet_number

Mas, para conseguir colocar isso em Julia, precisamos de números inteiros com
mais precisão. Vamos usar o BigInt.

#+begin_SRC julia :eval no-export :exports both
p1 = BigInt(37)
p2 = BigInt(73)
p3 = BigInt(109)   # ao fazer uma conta com o BigInt a conta continua desse tipo
p12 = p1 * p2
p13 = p1 * p3
p23 = p2 * p3
println(p12, " é de Poulet pois ", (2^(p12 -1) - 1) % p12, " é igual a zero")
println(p13, " é de Poulet pois ", (2^(p13 -1) - 1) % p13, " é igual a zero")
println(p23, " é de Poulet pois ", (2^(p23 -1) - 1) % p23, " é igual a zero")
p123 = p1 * p2 * p3
println(p123, " é de Poulet pois ", (2^(p123 -1) - 1) % p123, " é igual a zero")
#+end_SRC

#+RESULTS:
#+begin_example
37
73
109
2701
4033
7957
2701 é de Poulet pois 0 é igual a zero
4033 é de Poulet pois 0 é igual a zero
7957 é de Poulet pois 0 é igual a zero
294409
294409 é de Poulet pois 0 é igual a zero
#+end_example

**** Questão 4
Dada uma lista com pares de quantidades e números faça uma função chamada
transforma que recebe essa lista inicial, e devolve a lista onde no lugar de
cada par o número é escrito o número de vezes dado.

Exemplo: se $l = [2, 3, 4, 5, 0, 3, 1, 100]$,  transforma(l)
devolve: $[3, 3, 5, 5, 5, 5, 100]$.

** Aula 15 - Problemas reais
:PROPERTIES:
:EXPORT_FILE_NAME: aula_15.pdf
:END:
Nas próximas duas aulas, vamos resolver  problemas reais. Partindo de uma modelagem
e chegando aos algoritmos com uma solução. Os códigos apresentados abaixo foram propostos
em 2021, em uma turma de MAC0115 na Física da USP. Os alunos participaram da solução encontrada.

O primeiro problema é entender como se revela uma estratégia para se jogar em um jogo de roleta, como
se fosse em um cassino.

De uma forma geral, para se jogar em uma roleta, deve-se fazer uma aposta e conforme a aposta pode
se ganhar um valor proporcional ao apostado. Por exemplo, quando se escolhe uma característica, como
par ou ímpar (chance de 50%), em caso de acerto se paga o valor apostado. Em caso de erro, o valor
apostado é perdido.

Mas, como jogos de azar são conhecidos por geralmente não colaborarem com os
apostadores, no jogo da roleta, além dos números entre 1 e 36, há também o
número zero. O seu significado é que todos perderam na rodada onde ele
ocorre. Isso implica que a chance de ganhar na roleta é sempre um pouco menor do
que deveria ser. Para simplificar o modelo, vamos assumir que a única aposta disponível
é par ou ímpar.

Logo, para termos um código que modela o jogo de roleta, precisamos para começar de
uma forma de se sortear números entre 0 e 36.

isso pode ser conseguido com o código a seguir:

#+begin_SRC julia :eval no-export :exports both
function roleta()
    return rand(0:36)
end
#+end_SRC

#+RESULTS:
: roleta (generic function with 1 method)

Para vermos como se comportam os sorteios, podemos por exemplo imprimir 10 rodadas:

#+begin_SRC julia :eval no-export :exports both
function chamaRoleta()
    for i in 1:10
        println(roleta())
    end
end
chamaRoleta()
#+end_SRC

Inclusive, um primeiro teste que podemos fazer é o de verificar se a roleta dada pela
função roleta() é honesta. Para isso podemos fazer várias rodadas de forma a descobrir
se a distribuição dos números é justa.

#+begin_SRC julia :eval no-export :exports both
function testeRoleta()
    v = zeros(Int, 37)
    for i in 1:10000000
        sorteio = roleta()
        if sorteio == 0
            v[37] = v[37] + 1
        else
            v[sorteio] = v[sorteio] + 1
        end
    end
    println("O zero apareceu: ", v[37], " vezes")
    for i in 1:36
        println("O ", i, " apareceu: ", v[i], " vezes")
    end
end
#+end_SRC

Agora, sabendo que a nossa roleta é justa. Podemos pensar em avaliar uma jogada,
no caso a aposta em um número par. Outras estratégias poderiam ser tentadas, mas
como o código é análogo, vamos nos restringir ao código seguinte.

#+begin_SRC julia :eval no-export :exports both
function jogadaPar(valor)
    sorteio = roleta()
    if sorteio == 0
        return 0
    end
    if sorteio % 2 == 0
        return 2 * valor
    else
        return 0
    end
end
#+end_SRC

Nele o coportamento é bem simples, ao jogar um valor, a função ou devolve zero,
em caso de não acertar (se for zero ou ímpar) ou o dobro se o jogador acertou.

Com as funções acima já podemos pensar em como implementar uma estratégia de jogo.
Nela, vamos limitar a quantidade de jogadas a 100, um número que parece razoável para
um dia no jogando na roleta. A função estrategiaSimples() começa com um valor inicial,
e devolve o valor obtido após o "dia" de jogadas. Há duas possibilidades, se o jogador
continua com verba, ele faz uma aposta entre 1 e 100 até completar 100 jogadas. Caso ele
perca todo o valor inicial, a função devolve zero.

#+begin_SRC julia :eval no-export :exports both
function estrategiaSimples(valor)
    for i in 1:100
        aposta = rand(1:100)
        if aposta > valor
            aposta = valor
        end
        valor = valor - aposta
        premio = jogadaPar(aposta)
        valor = valor + premio
        if valor == 0
            break
        end
    end
    return valor
end
#+end_SRC

Baseado na estratégia simples, podemos pensar na estratégia empolgada. Se o jogador ganhou,
ele aposta um valor maior do que o anterior, caso contrário continua apostando um valor entre
1 e 100. O comportamente é o mesmo no caso de acabar o dinheiro.

#+begin_SRC julia :eval no-export :exports both
function estrategiaEmpolgada(valor)
    aposta = rand(1:100)
    for i in 1:100
        if aposta > valor
            aposta = valor
        end
        valor = valor - aposta
        premio = jogadaPar(aposta)
        valor = valor + premio
        if premio > 0
            aposta = aposta + rand(1:aposta)
        else
            aposta = rand(1:100)
        end
        if valor == 0
            break
        end
    end
    return valor
end
#+end_SRC

Uma estratégia final, um pouco mais elaborada é a estratégia exponencial, onde o jogador
tenta sempre garantir que vai ganhar 1, ou seja, faz uma aposta com valor 1. Se ganhou repete
a aposta com valor 1, caso contrário joga o dobro, e assim de forma sucessiva até ganhar. Teoricamente,
se a quantidade de dinheiro do jogador é infinita, em algum momento ele ganha.

#+begin_SRC julia :eval no-export :exports both
function estrategiaExponencial(valor)
    aposta = 1
    for i in 1:100
        if aposta > valor
            aposta = valor
        end
        valor = valor - aposta
        premio = jogadaPar(aposta)
        valor = valor + premio
        if premio > 0
            aposta = 1
        else
            aposta = 2 * aposta
        end
        if valor == 0
            break
        end
    end
    return valor
end
#+end_SRC

Para saber se uma estratégia funciona bem, podemos simular um ano de jogatina, onde o
jogador começa com uma valor inicial. Enquanto ele tiver dinheiro, o jogador aposta
diariamente. Ao final do ano, se ele ainda tiver saldo positivo o valor é mostrado,
caso contrário a função devolve zero.

#+begin_SRC julia :eval no-export :exports both
function umAnoJogando(j)
    somaGanho = 0
    somaPerda = 0
    valorInicial = 50000
    for i in 1:365
        valorFinal = Estrategia(j, valorInicial)
        if valorFinal < valorInicial
            somaPerda = somaPerda + valorInicial - valorFinal
        else
            somaGanho = somaGanho + valorFinal - valorInicial
        end
        valorInicial = valorFinal
        if valorFinal == 0
            #println("Perdeu tudo, no dia ", i)
            break
        end
    end
    #println("Ao final, ganhou ", somaGanho, " perdeu ",
    #        somaPerda)
    #println("Saldo final ", valorInicial)
    return valorInicial
end
#+end_SRC

Como a única mudança na função acima é a estratégia, podemos usar a seguinte
função que permite a escolha das diversas estratégias.

#+begin_SRC julia :eval no-export :exports both
function Estrategia(i, valor)
    if i == 1
        return estrategiaSimples(valor)
    elseif i == 2
        return estrategiaEmpolgada(valor)
    else
        return estrategiaExponencial(valor)
    end
end
#+end_SRC

Finalmente, para verificar as possibilidades de cada estratégia, vamos simular 100 anos
jogando cada uma das estratégias. Vendo quando o saldo final é maior que o inicial. Ou seja
qual a chance de conseguir ganhar dinheiro.

#+begin_SRC julia :eval no-export :exports both
function umAnoJogandoTudo()
    valorInicial = 50000
    simples = 0
    empolgada = 0
    exponencial = 0
    for i in 1:1000
        #println("Estrategia simples")
        if umAnoJogando(1) >= valorInicial
            simples = simples + 1
        end
        #println("Estrategia Empolgada")
        if umAnoJogando(2) >= valorInicial
            empolgada = empolgada + 1
        end
        #println("Estrategia Exponencial")
        if umAnoJogando(3) >= valorInicial
            exponencial = exponencial + 1
        end
    end
    println("Jogando 1000 anos, o número de anos com ganho são:")
    println("Resultado final: Simples: ", simples, " Empolgada ", empolgada, " Exponencial ", exponencial)
end
#+end_SRC


Como exercício final, você deve propor uma nova estratégia e analisar o quanto ela
é eficiente. Você pode optar por estratégias como a vista (par ou ímpar), ou estratégias
mais sofisticadas, mas nesse caso será necessário implementar os outros tipos de aposta.
Será que você consegue uma estratégia melhor que a Empolgada?

** Aula 16 - Lei de Benford
:PROPERTIES:
:EXPORT_FILE_NAME: aula_16.pdf
:END:
   A motivação da aula de hoje é Fazer um programa que lê um arquivo e devolve a
   distribuição dos primeiros dígitos para verificar se eles satisfazem a
   [[https://pt.wikipedia.org/wiki/Lei_de_Benford][Lei de Benford]]

   Para isso o primeiro desafio é fazer uma função que extrai o primeiro dígito de um
   número. Vamos começar com números inteiros, para isso seguem uns testes abaixo:

#+begin_SRC julia :eval no-export :exports both
using Test
@testset "Testes de Benford" begin
    @test extraiDigito(5) == 5
    @test extraiDigito(50) == 5
    @test extraiDigito(19) == 1
    @test extraiDigito(0) == 0
    @test extraiDigito(234) == 2
    @test extraiDigito(500005) == 5
    @test extraiDigito(10) == 1
end
#+end_SRC

Os testes cobrem vários casos, inclusive quando o caso anômalo do número
zero. Para resolver o problema, podemos usar a técnica já vista de descascar
números, ou seja usar a divisão inteira por 10.

#+begin_SRC julia :eval no-export :exports both
function extraiDigito(n)
           if n == 0
               return 0
           end
           while n >= 10
               n = n ÷ 10
           end
           return n
       end
#+end_SRC

Como podemos ver os testes passam, logo é hora de adicionar testes adicionais, com
números negativos e em ponto flutuante.

#+begin_SRC julia :eval no-export :exports both
@test extraiDigito(12.3) == 1
@test extraiDigito(4.5) == 4
@test extraiDigito(0.45) == 4
@test extraiDigito(0.0000405) == 4
@test extraiDigito(-12.3) == 1
@test extraiDigito(1234.3) == 1
@test extraiDigito(-0.3) == 3
@test extraiDigito(-0.000000000003) == 3
#+end_SRC

Primeiro uma boa surpresa, alguns dos testes passam, mas outros não.
Temos que resolver o caso de números negativos e números menores do que
zero. Além disso, houve o problema com 4.5, que pode ser resolvido com o
comando trunc.

#+begin_SRC julia :eval no-export :exports both
function extraiDigito(n)
    n = abs(n)
    if n == 0
        return 0
    end
    while n < 1
        n = n * 10
    end
    while n >= 10
        n = n ÷ 10
    end
    return trunc(Int, n)
end
#+end_SRC

Agora sim, temos uma função que extrai o dígito mais significativo de um número qualquer.
Sabendo que o primeiro dígito de um número não nulo pode valer de 1 a 9, a seguinte função
a partir de um vetor de números imprime a frequência dos dígitos.

#+begin_SRC julia :eval no-export :exports both
function distribuicao(v)
    tam = length(v)
    freq = zeros(9)
    for el in v
        dig = extraiDigito(el)
        if dig != 0
            freq[dig] = freq[dig] + 1
        else
            tam = tam - 1   # descarta os valores nulos
        end
    end
    for i in 1:9
        println("A frequência de ", i, " é ", 100*freq[i]/tam)
    end
end
#+end_SRC

Com a função acima, podemos verificar se o conteúdo de um vetor satisfaz a lei
de Benford. Para poder usar arquivos com números, como os disponíveis na página
https://testingbenfordslaw.com/ precisamos ler números de um arquivo. Isso pode
ser feito facilmente com os comandos open, readline e close, como abaixo:

#+begin_SRC julia :eval no-export :exports both
function leArquivo()
    f = open("NomeDoArquivo.txt", "r")
    v = []
    while !eof(f)
        s = readline(f)
        push!(v, parse(Float64, s))
    end
    close(f)
    distribuicao(v)
end
#+end_SRC

Mas, quem leu o artigo sobre a lei de Benford no início viu que há uma regra
também para o segundo dígito. O desafio dessa aula é escrever uma função que
extrai o segundo dígito de um número.

** Aula 17 - Curiosidades com vetores
** Aula 18 - Ainda Mais sobre Vetores
:PROPERTIES:
:EXPORT_FILE_NAME: aula_18.pdf
:END:

*** Um pouco mais de manipulação de vetores (com merge e busca) e mudança de base
Faça uma função, onde dados dois vetores ordenados u e v,
sem repetição, devolve o vetor ordenado com os elementos de u
e v, sem repetição.

#+begin_SRC julia :eval no-export :exports both
function merge(u, v)
  pu = 1   # ponteiro em u
  pv = 1   # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
       push!(resp, u[pu])
       pu = pu + 1
    elseif v[pv] < u[pu]
       push!(resp, v[pv])
       pv = pv + 1
    else
       push!(resp, v[pv])
       pu = pu + 1
       pv = pv + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
  end
  return resp
end
#+end_SRC


Acima, vimos como fazer um dos problemas de merge, isso, é
dados dois vetores ordenados sem repetição, devolver um vetor que
corresponda a união deles sem repetição.


Com pequenas variações nesse código, podemos fazer outros tipos de merge:
- Fazer a intersecção
- Fazer a diferença (isso é, elementos devolver apenas elementos que estão
em u, mas não e, v

Todas essas soluções se baseiam em variações do código acima. Tudo isso
sabendo que os vetores originais estão ordenados e sem repetição.

Aproveitando, como podemos fazer para dado um vetor ordenado, com repetições,
devolver um vetor ordenado sem repetições?

#+begin_SRC julia :eval no-export :exports both

#+end_SRC

A ordenação também pode ser útil para verificar se um elemento está em
um vetor, mas vamos começar com a versão simples, de percorrer todo o vetor.

Para isso, faremos uma função que recebe um vetor e um elemento, caso o
elemento pertença ao vetor, devolvemos sua posição, caso contrário devolvemos
0.

#+begin_SRC julia :eval no-export :exports both
function posicaonovetor(v, el)
  for i in 1:length(v)
    if el == v[i]
      return i
    end
  end
  return 0
end
#+end_SRC

A solução acima funciona, mas ela não considera que o vetor está ordenado.
Para tentar entender uma solução melhor (busca binária), vamos fazer uma
brincadeira. Um voluntário vai pensar em um número entre 0 e 1023 e vou
advinhá-lo em até 10 tentativas, sendo que as respostas podem ser:
- Número encontrado
- O número que eu pensei é maior
- O número que eu pensei é menor

A lógica por trás dessa solução é que eu quero eliminar a maior quantidade
de números a cada palpite, para fazer isso, o melhor é pensar em um
palpite no "meio", que elimine metade dos números em questão.

Vamos agora desenvolver um algoritmo que faz a busca binária.
Mas, como ele é um pouco mais complicado, vamos começar com os testes,
validar os testes com a função anterior (posição no vetor) e finalmente
escrever o nosso algoritmo de busca binária.

#+begin_SRC julia :eval no-export :exports both

#+end_SRC

Na aula que vem veremos algumas formas de se ordenar um vetor,
sim Julia tem as funções sort() e sort!(). Mas, a motivação por
trás de aprender a ordenar é aprender como fazê-lo.

Um último exercício, dado que temos um vetor de tamanho $n$ e que vamos fazer $b$ buscas
nele, será que vale a pena ordenar antes de fazer as buscas?


*** Mudança de base
Vamos começar com umas ideias intuitivas, na base 10, temos os
dígitos de 0 a 9, e os números são agrupados de forma que o menos
significativo corresponde à base 10^0, o segundo à base 10¹ e assim
por diante.

Logo, um número como o 123 é na verdade igual a $3 * 10^0 + 2 * 10^1 + 1*10^2$.
Isso é tão natural que usamos naturalmente, sem pensar em base quando
falamos em base decimal.

O mesmo vale para outras bases, como a binária:

10010 é igual a 0 * 2^0 + 1 * 2^1 + 0 * 2^2 + 0 * 2^3 + 1 * 2^4 ou seja é
igual a 18 na base 10.

Dessa forma, podemos pensar em como devolver o valor na
base 10, para um número qualquer na base 2.

#+begin_SRC julia :eval no-export :exports both
function valorbase2(n)
  pot = 0
  soma = 0
  while n != 0
    dig = n % 10
    soma = soma + dig * 2 ^pot
    n = n ÷ 10
    pot = pot + 1
  end
  return soma
end
#+end_SRC

Há duas coisas a observar acima, o código pode ser melhorado e
podemos pensar em outras bases que não sejam apenas a binária (a
dificuldade de trabalhar com bases maiores do que 10 é devido
às variáveis inteiras terem apenas os dígitos de 0 a 9).

Mas, vamos fazer isso de uma forma iterativa, usando testes
 automatizados.

Após vermos como ter um número em uma base menor, na base 10,
vamos ver como transformar um número na base 10, em outra base.
Comecemos com a binária:

Temos as potências: 1, 2, 4, 8, 16, 32, 64, ...
Como escrever o número 99 em binário?
Começamos pela parte menos significativa, isso é, 99 % 2, e continuamos
com a sobra da parte mais significativa, isso é, 99 % 2 (= 1) e
 99 \div 2 (= 49), e repetimos o mesmo procedimento.

#+begin_SRC julia :eval no-export :exports both

#+end_SRC

Mas, não vamos esquecer dos nossos testes :)

Olhando os códigos com cuidado, dá para generalizar?


** Aula 19 - Ordenação
:PROPERTIES:
:EXPORT_FILE_NAME: aula_19.pdf
:END:


Tem que colocar conteúdo aqui

** Aula 20 - Ainda ordenação
:PROPERTIES:
:EXPORT_FILE_NAME: aula_20.pdf
:END:


Nessa aula vamos continuar vendo a ordenação, mas antes disso,
vamos finalmente ver o algoritmo de busca binária para
encontrar um elemento em um vetor ordenado.

*** Busca binária
Ao invés de percorrer o vetor, desde o início, procurando o
elemento como em:
#+begin_SRC julia :eval no-export :exports both
function buscaLinear(x, v)
  for i in 1:length(v)
    if v[i] == x
      return i
    end
  end
  return 0 # não encontrou o x em v[]
end
#+end_SRC

Podemos a cada procura, para ver se o elemento está
no vetor, eliminar metado do vetor. Se o elemento for
menor que o meio, olhamos do começo ao meio. se for maior
que o meio, olhamos do meio ao fim. Se for igual, achou.

#+begin_SRC julia :eval no-export :exports both
function buscaBinaria(x, v)
   inicio = 1
   fim = length(v)
   while in <= fim
      meio = div(inicio + fim, 2)
      if v[meio] == x
        return meio
      elseif x < v[meio]
        fim = meio - 1
      else
        inicio = meio + 1
      end
   end
   return 0
end
#+end_SRC

 Há também a versão recursiva, para isso temos que ter
o inĩcio e o fim como parâmetros.

#+begin_SRC julia :eval no-export :exports both
function buscaBinariaRec(inicio, fim, x, v)
   if inicio > fim
     return 0
   end
   meio = div(inicio + fim, 2)
   if v[meio] == x
     return meio
   elseif x < v[meio]
     buscaBinariaRec(inicio, meio - 1, x, v)
   else
     buscaBinariaRec(meio + 1, fim, x, v)
   end
end
#+end_SRC

*** Métodos de busca mais elaborados

Uma forma mais eficiente de se ordenar um vetor é usando a divisão e conquista,
isso é, dado um vetor, quebramos em duas partes, ordenamos as partes e depois
fazemos o merge, no caso como podemos ter repetição, vamos usar a versão que
permite duplicação.

#+begin_SRC julia :eval no-export :exports both
function merge(u, v)
  pu = 1  # ponteiro em u
  pv = 1  # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
      push!(resp, u[pu])
      pu = pu + 1
    elseif v[pv] < u[pu]
      push!(resp, v[pv])
      pv = pv + 1
    else
      push!(resp, v[pv])
      pu = pu + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
    end
  return resp
end
#+end_SRC

 Dado o merge, a ideia é:
- Divida o vetor no meio
- Ordene cada metade separadamente
- Devolva o merge

Para isso vamos ver mais uma possibilidade de Julia,
dado um vetor v, v[1:meio] cria um vetor até o meio e
v[meio + 1:length(v)] cria um vetor do meio + 1 ao final.

Com isso fica fácil fazer o mergeSort.

#+begin_SRC julia :eval no-export :exports both
function mergeSort(v)
  if length(v) <= 1
    return v
  end
  meio = div(length(v), 2)
  v1 = v[1:meio]
  v2 = v[meio + 1:length(v)]
  v1ord = mergeSort(v1)
  v2ord = mergeSort(v2)
  return merge(v1ord, v2ord)
end
#+end_SRC

 Vamos ao último algoritmo, que também fica melhor de forma
recursiva, dado um vetor, o primeiro passo é escolher um elemento
 de forma a dividir o vetor em duas partes, quem for menor ou
igual a esse elemento, e quem for maior. Isso deve ser feito
de forma recursiva.

#+begin_SRC julia :eval no-export :exports both
function quick!(i, j, v)
    if j > i
        pivo = v[div(i+j, 2)]
        left = i
        right = j
        while left <= right
            while v[left] < pivo
                left += 1
            end
            while v[right] > pivo
                right -= 1
            end
            if left <= right
                v[left], v[right] = v[right], v[left]
                left += 1
                right -= 1
            end
        end
        quick!(i, right, v)
        quick!(left, j, v)
    end
    return v
end
#+end_SRC
** Aula 21 - Indo além de vetores
:PROPERTIES:
:EXPORT_FILE_NAME: aula_21.pdf
:END:

Nessa aula o objetivo é ir além de vetores, primeiro entendendo que em
Júlia o que se pode fazer com vetores é bem flexível, em seguida vamos
ver que vetores podem ter várias dimensões. Veremos ao final alguns algoritmos
com matrizes.

*** Indo além de vetores
Conforme já vimos antes, os vetores ocupam várias posições de
memória, uma forma de se inicializar um vetor é através da função
zeros. Que cria um vetor com valores nulos.

#+begin_SRC julia :eval no-export :exports both
zeros(1)
zeros(100)
zeros(Int8, 3)
#+end_SRC

A novidade é que agora o zeros pode criar também vetores de mais
de uma dimensão, ou matrizes.
#+begin_SRC julia :eval no-export :exports both
zeros(3,3)
zeros(Int, 2, 2)
#+end_SRC

Duas outras funçÕes interessantes são a ones() com comportamento
similar a zeros(), e a rand() que cria vetores ou matrizes com
números aleatórios.

O comando fill() serve para fazer isso com um valor específico.
#+begin_SRC julia :eval no-export :exports both
ones(3, 3)
rand(4, 4)
rand(1: 10, 5, 5)
fill(42, 3, 3, 3)
#+end_SRC

Também é possível criar matrizes diretamente.

#+begin_SRC julia :eval no-export :exports both
m = [1 2 3; 4 5 6; 7 8 9]
#+end_SRC

O comando length() funciona para matrizes, mas devolve o seu tamanho
total, mas temos também os comandos ndims() e size().


A linguagem Julia ainda oferece vários açucares sintáticos, vejamos o
exemplo abaixo.
#+begin_SRC julia :eval no-export :exports both
a = [1 2; 3 4]
b = [1 0; 0 1]
a * b
a .* b
#+end_SRC

Mas, lembrando que o objetivo da disciplina é ensinar algoritmos, vamos
ver alguns.

Uma função que imprime uma matriz quadrada m.

#+begin_SRC julia :eval no-export :exports both
function imprimeMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          print(" m[", i, ", ", j, "] = ", m[i,j])
        end
        println()
    end
end
#+end_SRC


Faça uma função que recebe uma matriz quadrada e devolve a soma dos seus
elementos.

#+begin_SRC julia :eval no-export :exports both
function somaMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          soma = soma + m[i, j]
        end
     end
     return soma
  end
#+end_SRC

Uma matriz quadrada bidimensional é um quadrado mágico se a soma dos elementos
de cada linha, de cada coluna e das diagonais é sempre igual. Faça uma função
que dada uma matriz quadrada m, verifica se ela é um quadrado mágico.

#+begin_SRC julia :eval no-export :exports both
function QuadradoMagico(m)
    if length(m) == 1
      return true
    end
    a = size(m)
    if length(a) != 2 || a[1] != a[2]
      return false
    end
    somaP = 0
    for i in 1:a[1]
      somaP = somaP + m[i, i]
    end
    soma = 0
    for i in 1:a[1]
       soma = soma + m[i, a[1] - i + 1]
    end
    if somaP != soma
       return false
    end
    for i in 1:a[1]
       somaL = 0
       somaC = 0
       for j in 1:a[2]
          somaL = somaL + m[i, j]
          somaC = somaC + m[j, i]
       end
       if somaL != somaP || somaC != somaP
          return false
       end
    end
    return true
end
#+end_SRC

** Aula 22 - Ainda matrizes
:PROPERTIES:
:EXPORT_FILE_NAME: aula_22.pdf
:END:

Dadas duas matrizes m e n, faça uma função que devolva o
produto delas (sem usar o * para matrizes).

 #+begin_SRC julia :eval no-export :exports both
function multiplica(a, b)
   dima = size(a)
   dimb = size(b)
   if dima[2] != dimb[1]
     return -1
   end
   c = zeros(dima[1], dimb[2])
   for i in 1:dima[1]
      for j in 1:dimb[2]
         for k in 1:dima[2]
            c[i, j] = c[i, j] + a[i, k] * b[k, j]
         end
       end
   end
   return c
 end

 #+end_SRC

Uma matriz quadrada de tamanho n é um quadrado latino se em cada linha e coluna
aparecem todos os valores de 1 a n. Faça uma função que dada uma matriz
quadrada verifica se ela é um quadrado latino.

#+begin_SRC julia :eval no-export :exports both

#+end_SRC

Dizemos que uma matriz inteira A nxn  é uma matriz de permutação se em cada linha e em cada
coluna houver n-1 elementos nulos e um único elemento igual a 1. Faça uma função que recebe
uma matriz quadrada e que verifica se ela é uma matriz de permutação.

#+begin_SRC julia :eval no-export :exports both

#+end_SRC

Mas, conforme a abstração que fazemos as matrizes podem representar coisas diferentes,
por exemplo dada uma matriz quadrada n x n, a posição a[i][j], pode indicar se há um caminho
entre a cidade i e a cidade j.

Da mesma forma, a[i][j] pode representar a distância entre a cidade i e a cidade j. Com isso, podemos
ter problemas mais sofisticados como saber se dá para chegar da cidade i na cidade j, ou o custo
do menor caminho.

Nessa aula, vamos ver, um exemplo mais elaborado do uso de matriz, através de uma teoria conhecida
como percolation. Vamos primeiro entender o que seria isso usando o livro do Sedgewick e do Wayne
https://introcs.cs.princeton.edu/java/24percolation/

A pergunta é saber qual é a probabilidade, a partir da qual a percolation ocorre com grande
chance (digamos mais de 80%, ou seja em 100 tentativas, em 80 ocorre a percolation). Vamos para simplificar
o problema pensar em matrizes 20 por 20.

Como resolver esse problema?


** Aula 25 - C para quem programa em Julia
:PROPERTIES:
:EXPORT_FILE_NAME: aula_25.pdf
:END:

Como vocês devem lembrar, na primeira aula deixei claro que a linguagem de programação
era apenas o meio de se traduzir algum conceito algorítmico para o computador, de forma
a permitir a sua execução.

Como infelizmente, Julia ainda não é uma linguagem bastante conhecida, várias outras
linguagens mais tradicionais farão compania para vocês no curso. Conhecer várias linguagens
não é ruim, mas por outro lado Julia não ser conhecida é :)

Nessa aula, a ideia é apresentar a linguagem C para quem já programa em Julia. Há algumas
diferenças básicas

*** Compilado versus Interpretada
 Enquanto Julia é uma linguage interpretada, C é uma linguagem compilada, isso é, a partir
de um código fonte, ao se passar pelo compilador, é gerado um código objeto, que se correto,
pode ser executado na arquitetura para qual foi compilado.

Vejamos um primeiro código em C.
#+begin_src C
  #include <stdio.h>
  int main() {
    printf ("Hello World!\n");
  }
#+end_src

Para compilar o código acima, usamos o comando

#+BEGIN_CENTER
gcc um.c
#+END_CENTER
Que vai gerar um arquivo executável a.out, que se chamado imprime
a mensagem. O ponto de entrada inicial de um programa em C é único
e é a função main().

Mas, dá para ver mais umas coisas no código acima que são diferenças
em relação à Julia. Mesmo para coisas básicas como impressão é necessário
incluir bibliotecas, no caso a stdio.h que possui a função printf().

Os blocos são definidos com chaves (abre e fecha) e o ponto e vírgula
delimita os comandos.

Além disso, já dá para ver que C é fortemente tipado, isso é, é necessário
dizer o tipo de tudo ou seja, a função main() acima, não devolve nada.

*** Linguagem Tipada

Para cada variável em C, é necessário definir o seu tipo, vamos a mais
um exemplo:

#+BEGIN_CENTER
 #include <stdio.h>
  void main() {
    int a = 1;
    int b = 2;
    int c;
    c = a + b
    printf ("O valor de c é %d\n", c);
  }

#+END_CENTER

Acima é possível ver que podemos dar o tipo e definir a variável na mesma linha, ou
declarar e depois usar. Não é possível usar uma variável sem declarar explicitamente.
Isso tem vantagens claras, pois possíveis erros podem ser encontrados já em tempo de
compilação, antes da execução.

O comando de impressão também segue uma sintaxe diferente, recebendo primeiro uma
string, e depois uma lista de parâmetros. Nessa string, para saber como imprimir cada um
dos parâmetros e usar %, no caso %d para inteiros, %g para ponto flutuante e %s para string.
O \n no final é um indicativo para pular linha.

A declaração de funções é semelhante, só que para cada variável passada como parâmetro é
necessário passar o seu tipo. Os tipos mais comuns em C são, int, char, float e double.
Não há o tipo boolean em C, o que se faz é usar comparações, ou tipos inteiros, basicamente
0 equivale a falso e outros valores a verdadeiro.

#+BEGIN_CENTER
#include <stdio.h>

int soma(int a, int b){
  return a + b;
}
void main() {
  int a = 1;
  int b = 2;
  printf ("O valor  é %d\n", soma(a, b));
  if (soma(a, b) == 3)
    printf(" Verdade = %d\n", soma(a, b) == 3);  // Bloco sem chaves
}
#+END_CENTER

No código acima podemos ver que se o bloco tem apenas uma instrução,
não precisa usar as chaves.

Assim como em Julia, a recursão também funciona bem em C.

*** Comandos diferentes
Já o for em C é composto por três parâmetros, todos opcionais,
a inicialização, a condição e o passo.

#+BEGIN_CENTER
 #include <stdio.h>
void main(){
  for (int p = 1; p <= 512; p *= 2) {
    printf("%d\n", p);
  }
}
#+END_CENTER


A sintaxe do if é um pouco diferente, principalmente no que se refere ao
uso de elses. Vejamos um exemplo e aproveitemos para usar o comando de
entrada de dados pelo teclado, o scanf

Comando switch

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um número: ");
  scanf("%d", &n);
    if (n < 0)
      printf("Número negativo\n");
      else if (n > 0)
        printf("Número positivo\n");
        else
          printf("zero\n");
}
#+END_CENTER

Observem que quanto mais elses, mais iríamos para a direita, logo isso
se escreve de uma forma alternativa:

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um número: ");
  scanf("%d", &n);
    if (n < 0)
      printf("Número negativo\n");
    else if (n > 0)
      printf("Número positivo\n");
    else
      printf("zero\n");
}
#+END_CENTER


Mas, o principal acima é o operador &, que obtém o endereço de
uma variável, ou seja a sua posição na memória, podemos ver o efeito
disso na seção abaixo.

Mas, antes um exemplo do uso de switch.

#+BEGIN_CENTER
#include <stdio.h>
void main()
{
    int n;

    printf("Qual a sua carta (1-13)? ");
    scanf("%d", &n);
    switch (n) {
      case  1: printf("Ace\n"); break;
      case 11: printf("Jack\n"); break;
      case 12: printf("Queen\n"); break;
      case 13: printf("King\n"); break;
      default: printf("%d\n", n);
    }
}
#+END_CENTER
*** Vetores e ponteiros

Vejamos o exemplo abaixo, o primeiro a lidar com ponteiros de forma
mais explícita.

#+BEGIN_CENTER
#include <stdio.h>
void naoModifica(int a){
  a = 2;
}
void Modifica(int *a){
  *a = 2;
}

void main(){
  int n = 3;

  printf("A variável n vale %d\n", n);
  naoModifica(n);
  printf("A variável n vale %d\n", n);
  Modifica(&n);
  printf("A variável n vale %d\n", n);
}
#+END_CENTER

O mais próximo que vimos de ponteiros em Julia foi o
conceito de vetores, onde um vetor também é um ponteiro,
mas que também guarda o seu tamanho.

Vamos a um exemplo de vetores em C.

#+BEGIN_CENTER
#include <stdio.h>
#include <stdlib.h>

void imprimeVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    printf("v[%d] = %d  ",i, v[i]);
  printf("\n");
}

void inicializaVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = rand() % 100;
}

void vezes2Vetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = 2 * v[i];
}



void main()
{
  int vetor[10];
  inicializaVetor(vetor, 10);
  imprimeVetor(vetor, 10);
  vezes2Vetor(vetor, 10);
  imprimeVetor(vetor, 10);
}
#+END_CENTER

Mas, com grandes poderes vem grandes responsabilidades, veja o programa abaixo com
uma pequena modificação e um erro inserido.


* Emacs Setup                                      :noexport:ignore:
See [[Configurações LaTeX]] above for the LaTeX configuration

** Use shell-escape
If you  accept this definition  when loading the  buffer, this variable  will be
modified locally to the buffer.  This allows using XeLaTeX for exporting to pdf.

# Local Variables:
# eval: (setq-local org-latex-pdf-process (list "latexmk -pdflatex -shell-escape %f"))
# eval: (add-to-list 'org-babel-default-header-args:bash
#                    '((:exports . "both")
#                      (:eval . "no-export")))
# End:
