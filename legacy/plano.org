#+STARTUP: overview indent inlineimages logdrawer
#+TITLE:  Alfredo's MAC0110 Journal
#+AUTHOR:      Alfredo Goldman
#+LANGUAGE:    bt-br
#+TAGS: noexport(n) Stats(S)
#+TAGS: Teaching(T) R(R) OrgMode(O) Python(P)
#+TAGS: Book(b) Code(C) FPGA(F) Autotuning(A)
#+TAGS: ExportableReports(E)
#+TAGS: DataVis(v) PaperReview(W)
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage{amsmath,amsfonts,amssymb,amsthm}
#+LATEX_HEADER: \usepackage{sourcecodepro}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \usepackage{colortbl}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage[scale=2]{ccicons}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{relsize}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage{pgfplots}
#+LATEX_HEADER: \usepackage{todonotes}
#+LATEX_HEADER: \usepgfplotslibrary{dateplot}
#+LATEX_HEADER: \lstdefinelanguage{ein-julia}%
#+LATEX_HEADER:   {morekeywords={abstract,struct,break,case,catch,const,continue,do,else,elseif,%
#+LATEX_HEADER:       end,export,false,for,function,immutable,mutable,using,import,importall,if,in,%
#+LATEX_HEADER:       macro,module,quote,return,switch,true,try,catch,type,typealias,%
#+LATEX_HEADER:       while,<:,+,-,::,/},%
#+LATEX_HEADER:    sensitive=true,%
#+LATEX_HEADER:    alsoother={$},%
#+LATEX_HEADER:    morecomment=[l]\#,%
#+LATEX_HEADER:    morecomment=[n]{\#=}{=\#},%
#+LATEX_HEADER:    morestring=[s]{"}{"},%
#+LATEX_HEADER:    morestring=[m]{'}{'},%
#+LATEX_HEADER: }[keywords,comments,strings]%
#+LATEX_HEADER: \lstset{ %
#+LATEX_HEADER:   backgroundcolor={},
#+LATEX_HEADER:   basicstyle=\ttfamily\scriptsize,
#+LATEX_HEADER:   breakatwhitespace=true,
#+LATEX_HEADER:   breaklines=true,
#+LATEX_HEADER:   captionpos=n,
# #+LATEX_HEADER:   escapeinside={\%*}{*)},
#+LATEX_HEADER:   extendedchars=true,
#+LATEX_HEADER:   frame=n,
#+LATEX_HEADER:   language=R,
#+LATEX_HEADER:   rulecolor=\color{black},
#+LATEX_HEADER:   showspaces=false,
#+LATEX_HEADER:   showstringspaces=false,
#+LATEX_HEADER:   showtabs=false,
#+LATEX_HEADER:   stepnumber=2,
#+LATEX_HEADER:   stringstyle=\color{gray},
#+LATEX_HEADER:   tabsize=2,
#+LATEX_HEADER: }
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller\relax}

* Programa do curso
** Aula 01 - [2020-03-02 seg]
Objetivo da aula: Dar uma ideia geral do que vai acontecer no semestre
*** Visão Geral do Curso
- Vamos começar em um ambiente amigável: Julia e Jupyter
- Em seguida vamos passar para linha de comando
  - Sim, compilação tem que ser explícita
- Após ver os primeiros programas em Julia
- Sim vamos ver outro paradigma: o funcional com Haskel
- Isso tudo cobrindo o conteúdo do curso
  - Sem esquecer controle de versão e testes automatizados
*** Conhecendo um pouco a classe
  No curso vamos usar o [[https://www.mentimeter.com][Menti]] uma ferramenta para pesquisas anônimas. Não tenha medo você não será identificado!
  Vamos começar:
 - Primeira Consulta:
    Quem já sabe programar?
 - Segunda Consulta:
    Qual a sua linguagem preferida?
 - Terceira Consulta:
    Qual o seu objetivo daqui a quatro anos?
*** Entendendo a necessidade de termos uma linguagem de programação
  Vou precisar de dois voluntários
  - Descrever como fritar um ovo para um extraterrestre?
  - Descrever escovar os dentes para um homem pré histórico?
  Para os dois casos, vamos abstrair que a linguagem falada e/ou escrita seja um problema.
  Exemplo popular (geração youtube): [[https://www.youtube.com/watch?v=Ct-lOOUqmyY][Como passar manteiga de amendoim]]
  Uma linguagem é uma forma de se expressar:
  - Dados (números, letras, etc)
  - Procedimentos (formas de manipular dados)
  Só lembrando procedimentos também podem ser dados :)
*** Lógica de programação é uma coisa natural
 Vamos ver um exemplo da Internet, conhecido como teste de Einsten, vou pegar
a formulação do sítio [[https:://www.geniol.com.br/logica/problemas/teste-de-einstein/][Geniol]]
*** O curso em si
- Exercícios Programa
- Mini Exercícios Programa (correção binária)
- Provas
Programar é como andar de bicileta, só se aprende programando!
Plágio é inaceitável, com punições severas

Recomenda-se fortemente que os alunos usem um ambiente baseado em Linux!
Programadores raiz usam linha de comando!

Linguagem: Vamos começar com Julia em um ambiente amigável, o Jupyter

O meu objetivo com o curso é que vocês aprendam ao final:
- Princípios básicos de algoritmos (ementa do curso)
- Controle de versões com o Git
- Noções de como programar em diferentes linguagens
  - A linguagem é apenas a ferramenta!
- Testes automatizados

Se você está ansioso é já quer começar a ver algum material, tem dois livros
disponíveis: o de [[https://benlauwens.github.io/ThinkJulia.jl/latest/book.html][Julia]] e o de [[https://sttp.site/][Testes]].
** Aula 02 - [2020-03-04 qua]
Objetivo da aula ter uma visão geral da evolução do Hardware e das linguagens de programação
*** História da Computação
   Slides do Pedro
*** Preparação para a próxima aula
Pode ser útil já ter o ambiente de desenvolvimento com Julia instalado.
**** TODO Falar mais sobre Linux?
:LOGBOOK:
- State "TODO"       from              [2020-02-21 Fri 14:59]
:END:
** Aula 03 -[2020-03-09 seg]
Objetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a noção de variáveis
*** Começando com o modo interativo do Julia.
Quem quiser já pode instalar o ambiente de programação, usem esse [[https://julialang.org/][link]]

Dentro do Julia (após chamar julia na linha de comando), vamos começar com números inteiros:
#+NAME: 12228cf8-4dae-4454-8494-6e712c891426
#+begin_SRC ein-julia :results output :session localhost :async yes
1 + 2
#+end_SRC

#+RESULTS: 12228cf8-4dae-4454-8494-6e712c891426
: 3

#+RESULTS:
: 3

#+begin_SRC ein-julia :results output :session localhost :async yes
40 * 3
#+end_SRC

#+RESULTS:
: 120

#+begin_SRC ein-julia :results output :session localhost :async yes
84 / 2
#+end_SRC
Notem que nesse caso, houve uma mudança de tipos, pois 84 e 2 são inteiros e o resultado
é um número em ponto flutuante (float)
#+RESULTS:
: 42.0

Também é possível pedir o resultado inteiro usando o operador div:
#+begin_SRC ein-julia :results output :session localhost :async yes
div(84,2)
#+end_SRC

#+RESULTS:
: 42

Também dá para fazer a exponenciação:

#+begin_SRC ein-julia :results output :session localhost :async yes
2^31
#+end_SRC

#+RESULTS:
: 2147483648
 Expressões mais complexas também podem ser calculadas:

 #+begin_SRC ein-julia :results output :session localhost :async yes
23 + 2 * 2 + 3 * 4
 #+end_SRC

 #+RESULTS:
 : 39
 Sim, a precedência de operadores usual também é válida em Julia. Mas, ai
vem a primeira lição de programação: * Escreva para humanos, não para máquinas *

 #+begin_SRC ein-julia :results output :session localhost :async yes
23 + (2 * 2) + (3 * 4)
 #+end_SRC

Em julia também podemos fazer operações com números em ponto flutuante:

#+begin_SRC ein-julia :results output :session py :async yes
23.5 * 3.14
#+end_SRC

#+RESULTS:
: 73.79

ou
#+begin_SRC ein-julia :results output :session localhost :async yes
12.5 / 2.0
#+end_SRC

#+RESULTS:
: 6.25

Acima temos mais um exemplo de código escrito para pessoas, ao se escrever
2.0 estamos deixando claro que o segundo parâmetro é um número float.

É importante saber que números em ponto flutuante tem precisão limitada, logo não se espante com resultados inesperados como abaixo:

#+NAME: 62234de1-001d-4390-97af-e5ad203ac125
#+begin_SRC ein-julia :results output :session localhost
1.2 - 1.0
#+end_SRC

#+RESULTS: 62234de1-001d-4390-97af-e5ad203ac125
: [....]

ou
#+NAME: a9808540-b252-4b3e-80cf-f65127b343f5
#+begin_SRC ein-julia :results output :session localhost
0.1 + 0.2
#+end_SRC

#+RESULTS: a9808540-b252-4b3e-80cf-f65127b343f5
: [....]

ou ainda

#+NAME: e02fa7e7-b7b7-405c-9b89-fdb8f370bbb1
#+begin_SRC ein-julia :results output :session localhost
10e15 + 1 - 10e15
#+end_SRC

#+RESULTS: e02fa7e7-b7b7-405c-9b89-fdb8f370bbb1
: 0.0

Um outro operador interessante é o % que faz o resto da divisão

#+NAME: 4e403942-5d45-473a-90be-9b02690bbb25
#+begin_SRC ein-julia :results output :session localhost
4 % 3
#+end_SRC

#+RESULTS: 4e403942-5d45-473a-90be-9b02690bbb25
: 1

*** Variáveis e seus tipos
Em Julia também temos o conceito de variáveis, que servem para armazenar os
diferentes conteúdos de dados possíveis.

#+NAME: 0571e6f9-2ce1-4e7f-b0ae-408686fe4fb2
#+begin_SRC ein-julia :results output :session localhost :async yes
a = 7
2 + a
#+end_SRC

#+RESULTS: 0571e6f9-2ce1-4e7f-b0ae-408686fe4fb2
: 9

É importante notar que as variáveis em Julia podem receber novos valores e o tipo
da variável depende do que foi atrubuído inicialmente.

#+NAME: 7f85f7ed-67f8-44e7-bd41-a5e59e70f3f8
#+begin_SRC ein-julia :results output :session localhost :async
a = 3
a = a + 1
typeof(a)
#+end_SRC

#+RESULTS: 7f85f7ed-67f8-44e7-bd41-a5e59e70f3f8
: Int64

Aproveitando o momento, podemos ver que há vários tipos primitivos em Julia, sendo os
principais:

#+NAME: c715ca40-1dbb-46af-811f-e4432ae8ac0f
#+begin_SRC ein-julia :results output :session localhost :async yes :exports both
typeof(1)
typeof(1.1)
typeof("Bom dia")
#+end_SRC

#+RESULTS: c715ca40-1dbb-46af-811f-e4432ae8ac0f
: String

Falando em strings, elas são definidas por conjuntos de caracteres entre aspas como:
#+NAME: 573261b3-3e9a-43f6-ae48-3e8eb6cb86bb
#+begin_SRC ein-julia :results output :session localhost
s1 = "Olha que legal"
s2 = "Outra String"
#+end_SRC

#+RESULTS: 573261b3-3e9a-43f6-ae48-3e8eb6cb86bb
: "Outra String"

Dá também para fazer operações como strings como concatenação:

#+NAME: 60e75287-87fb-47e0-bc02-d56dc5cddde9
#+begin_SRC ein-julia :results output :session localhost
s1 = "Tenha um"
s2 = " Bom dia"
s3 = s1 * s2
#+end_SRC

#+RESULTS: 60e75287-87fb-47e0-bc02-d56dc5cddde9
: "Tenha um Bom dia"

Ou potência:

#+NAME: aa619a34-1c8d-4636-a7b5-2ae7bb8681ef
#+begin_SRC ein-julia :results output :session localhost
s = "Nao vou mais fazer coisas que possam desagradar os meus colegas"
s ^ 10
#+end_SRC

#+RESULTS: aa619a34-1c8d-4636-a7b5-2ae7bb8681ef
: [....]

Ainda sobre variáveis, há umas regras com relação aos seus nomes, tem que
começar com uma letra, pode ter dígitos e não pode ser uma palavra reservada.  É
bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em
unicode, pode exemplo

#+begin_SRC ein-julia :results output :async yes
\delta = 2  # Para se fazer o delta, deve se digitar \ seguido de delta, seguido de <tab>
#+end_SRC
*** Saída de dados
Para fazer saídas usam-se dois comandos, print() e o println(), sendo que o primeiro não pula linha e o segundo pula.
#+NAME: cab1bf67-75d1-441d-a756-7c1b1a3220de
#+begin_SRC ein-julia :results output :session localhost :async yes
print("Hello ")
println("World!")
println("Ola, mundo!")
#+end_SRC

#+RESULTS: cab1bf67-75d1-441d-a756-7c1b1a3220de

Para evitar que se digitem muitos caracteres, por vezes podemos usar "açucares sintáticos".

#+NAME: af7bbe44-209e-46a6-9b53-4cf52ccf8533
#+begin_SRC ein-julia :results output :session localhost
x = 1
x = x + 1
x += 1  # forma equivalente a acima
#+end_SRC

#+RESULTS: af7bbe44-209e-46a6-9b53-4cf52ccf8533
: 3

** Aula 04 -[2020-03-11 qua]
  Objetivo: Começar a entender como funcionam as funções
*** O uso de funções é uma abstração natural
Na aula passada já vimos umas funções e isso foi bem natural, foram elas:
- typeof() - Que dado um parâmetro devolve o seu tipo
- div() - Que dados dois parâmetros devolve a divisão inteira do primeiro pelo segundo
- print() e println() - Que dados diversos parâmetros os imprime, sem devolver nada
Inclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para saber o que fazem as
funções. Para isso, se usa o ? antes da função:
#+NAME: 1d02325a-f2a1-4175-8903-f509560cc245
#+begin_SRC ein-julia :results output :session localhost :async yes
?typeof()
?div()
?print()
#+end_SRC

#+RESULTS: 1d02325a-f2a1-4175-8903-f509560cc245
:
:
:   No documentation found.
:
:   Binding [36mtypeof() ?div() ?print()[39m does not exist.

Ao fazer isso, inclusive descobrimos que o div() pode ser usado também como \div.

Uma outra função bem útil é a que permite transformar um tipo de valor em outro.

#+NAME: 91a6eaca-2a85-4d05-a699-3707ce5c2a8f
#+begin_SRC ein-julia :results output :session localhost
parse(Float64, "32")
#+end_SRC

#+RESULTS: 91a6eaca-2a85-4d05-a699-3707ce5c2a8f
: 32.0

Para conversão de valores em ponto flutuante para inteiros, temos a função trunc.

#+NAME: a2c1f3da-d8f1-4d85-9d34-47113b32d716
#+begin_SRC ein-julia :results output :session localhost
trunc(Int64, 2.25)
#+end_SRC

#+RESULTS: a2c1f3da-d8f1-4d85-9d34-47113b32d716
: 2

De forma inversa temos o float.

#+NAME: 7810375a-7fd9-4fb3-bc89-6e02b3464f4c
#+begin_SRC ein-julia :results output :session localhost
float(2)
#+end_SRC

#+RESULTS: 7810375a-7fd9-4fb3-bc89-6e02b3464f4c
: 2.0

Finalmente, podemos transformar um valor em uma string, como em:

#+NAME: 1a904e1c-4613-4bb1-a574-2a2017aadfbc
#+begin_SRC ein-julia :results output :session localhost
string(3)
#+end_SRC

#+RESULTS: 1a904e1c-4613-4bb1-a574-2a2017aadfbc
: "3"
ou
#+NAME: 3a4b773d-d0c1-425d-8681-65c88a759726
#+begin_SRC ein-julia :results output :session localhost
string(3.57)
#+end_SRC

#+RESULTS: 3a4b773d-d0c1-425d-8681-65c88a759726
: "3.57"

Também tem muitas funções matemáticas prontas como
- sin(x) - calcula  seno de x em radianos
- cos(x)
- tan(x)
- deg2rad(x) - converte x de graus em radianos
- rad2deg(x)
- log(x) - calcula o logarítmo natural de x
- log(x, b) - calcula o logarítmo de x na base b
- log2(x) - calcula o logarítmo de x na base 2
- log10(x)
- exp(x) - calcula o expoente da base natural de x
- abs(x) - calcula o módulo de x
- sqrt(x) - calcula a raiz quadrada
- isqrt(x) - calcula a raiz quadrada inteira de x
- cbrt(x) - raiz cúbica de x
- factorial(x) - calcula o fatorial de x

Em julia também é possível criar funções conforme as suas necessidades, como abaixo:
#+NAME: 8f733746-e1b4-4a37-92b3-ae495090f020
#+begin_SRC ein-julia :results output :session localhost
function mensagemDeBomDia()
   println("Tenha um bom dia!")
end
#+end_SRC

#+RESULTS: 8f733746-e1b4-4a37-92b3-ae495090f020
: mensagemDeBomDia (generic function with 1 method)

Para usar uma função, basta chamá-la:

#+NAME: 5a983c1d-fbec-4f99-978a-7187dcb44a30
#+begin_SRC ein-julia :results output :session localhost
MensagemDeBomDia()
#+end_SRC

#+RESULTS: 5a983c1d-fbec-4f99-978a-7187dcb44a30


Funções, podem receber um ou mais parâmetros:

#+NAME: aa31a96d-c645-4598-9502-b97640374f82
#+begin_SRC ein-julia :results value :session localhost
function imprime(a)
   println(" Vou imprimir ", a)
end
imprime(42)
#+end_SRC

#+RESULTS: aa31a96d-c645-4598-9502-b97640374f82

Também é possível que uma função chame outra funçõa como em:

#+NAME: fab1fb94-6596-4001-94c4-1dad607e9546
#+begin_SRC ein-julia :results output :session localhost
function imprimeduasvezes(a)
   imprime(a)
   imprime(a)
end
imprimeduasvezes(13)
#+end_SRC

#+RESULTS: fab1fb94-6596-4001-94c4-1dad607e9546
O número de parâmetros determina qual a função correta deve ser chamada:
#+NAME: b0af26b3-0aba-4247-a13b-5ff581119f84
#+begin_SRC ein-julia :results output :session localhost
function recebe(a)
  println("Recebi um parametro: ", a)
end
function recebe(a, b)
  println("Recebi dois parametros: ", a, " ", b)
end

#+end_SRC

#+RESULTS: b0af26b3-0aba-4247-a13b-5ff581119f84
: recebe (generic function with 2 methods)

Conforme a chamada, a função chamada será diferente:

#+NAME: e828de2d-ece2-4d0a-b88b-abbbe5b2a701
#+begin_SRC ein-julia :results output :session localhost
recebe(1)
recebe(1, 2)
#+end_SRC

#+RESULTS: e828de2d-ece2-4d0a-b88b-abbbe5b2a701
Também dá para chamar funções com variáveis e com operações, como
em:

#+NAME: 89cea054-ece5-40d7-ac31-a652f461d94b
#+begin_SRC ein-julia :results output :session localhost
a = 10
recebe(a)
recebe(a, a + 1)

#+end_SRC

#+RESULTS: 89cea054-ece5-40d7-ac31-a652f461d94b

As funções que vimos até agora imprimem mensagens, mas não devolvem nada.
O typeof() delas é nothing, ou seja, algo que não pode ser atribuído.

Mas, também é possível fazer funções que devolvem valores, como:

#+begin_SRC ein-julia :results output :session localhost
function soma1(a)
  return a + 1
end
#+end_SRC

Nesse caso, se for passado um parâmetro numérico, a função devolverá o valor incrementado (adicionado de 1).

Claro que isso pode ser usado com fórmulas mais complicadas como:

#+begin_SRC ein-julia :results output :session localhost
function hipotenusa(a, b)
  hip = a * a + b * b
  return hip
end
#+end_SRC
ou para a verificação de fórmulas, como relações trogonométricas:
#+begin_SRC ein-julia :results output :session localhost
function verificaequacao(x)
  soma = sin(x)^2 + cos(x)^2
  return soma == 1.0
end
#+end_SRC
** Aula 05 - <2020-03-16 seg>
  Nessa aula, em meio ao caos de uma pandemia mundial, vamos aprender um novo comando.
O desvio condicional, através dele é possível alterar o fluxo de execução de um programa. Até o
momento não tínhamos comentado isso explicitamente, mas a ordem de execução de instruções segue
a ordem em que elas estão. Vejamos o exemplo abaixo:
#+NAME: cdbb133a-e6e7-4d78-bd70-8d7d41b5a949
#+begin_SRC ein-julia :results output :session localhost
println("Oi")
println("um")
println("dois")
#+end_SRC

#+RESULTS: cdbb133a-e6e7-4d78-bd70-8d7d41b5a949
: [....]

A ordem de impressão será Oi, um e dois.

Da mesma forma não temos problema ao executar o código abaixo.

#+NAME: e03586b7-6414-4a10-b43a-fd5345210d51
#+begin_SRC ein-julia :results output :session localhost
denominador = 0
denominador += 2
30 / denominador
#+end_SRC

#+RESULTS: e03586b7-6414-4a10-b43a-fd5345210d51
: [....]

Apesar da variável denominador começar inicialmente com 0, antes de se fazer a
divisão, ela estará valendo 2.

Como é de se esperar nem sempre queremos que essa ordem seja respeitada. Observe
o seguinte exemplo:

#+NAME: c8e3e174-d6fa-4175-a0ef-b572509afd3e
#+begin_SRC ein-julia :results output :session localhost
pandemia = true
println("Vou sair de casa?")
if pandemia == true
   println("Só vou sair de casa se for essencial")
end

#+end_SRC

#+RESULTS: c8e3e174-d6fa-4175-a0ef-b572509afd3e
: [....]
 O exemplo acima é claro, se uma condição for verdadeira, o código que
 está no escopo do if (isso é entre a condição e o end) será executado.

 Um outro exemplo:

 #+NAME: b7a9a3c7-cf10-41dc-9405-64e688e3d89a
 #+begin_SRC ein-julia :results output :session localhost
denominador = 0
if denominador != 0
   println("sei fazer a divisão se não for por zero")
   println("o resultado da divisão de 30 por ", denominador, " é igual a ", 30/denominador)
end


 #+end_SRC

 #+RESULTS: b7a9a3c7-cf10-41dc-9405-64e688e3d89a
 : [....]

 Situações muito comuns em computação devem ser favorecidas pela linguagem, nesse
caso do if, é muito comum termos duas ou mais situações. Nesse sentido em Julia podemos
também ter alternativas como abaixo:

 #+NAME: b363cb59-d5d8-449b-8474-f325b3b48db2
 #+begin_SRC ein-julia :results output :session localhost
pandemia = true
println("Vou sair de casa?")
if pandemia == true
   println("Só vou sair de casa se for essencial")
else
   println("Balada liberada")
end
 #+end_SRC

 #+RESULTS: b363cb59-d5d8-449b-8474-f325b3b48db2

No caso de termos mais de uma altenativa, não basta termos só uma condição,
nesse caso temos que usar elseif.

#+NAME: 2fa54533-0cf8-4cb4-b251-434a024649f1
#+begin_SRC ein-julia :results output :session localhost
pandemia = true
tenhoqueestudar = false
println("Vou sair de casa?")
if pandemia == true
   println("Só vou sair de casa se for essencial")
elseif tenhoqueestudar == true
   println("Melhor ficar em casa")
else
   println("Balada liberada")
end
#+end_SRC

#+RESULTS: 2fa54533-0cf8-4cb4-b251-434a024649f1
: [....]

 Conhecendo o if, agora, escreva uma função que recebe os coeficientes, a, b e c de uma
equação de segundo grau e imprime as suas raízes reais.

 Espaço para a solução aqui :)

 Vamos agora a parte mais importante da aula, lembrando que até o momento aprendemos:
**** valores
**** varíaveis e alguns dos seus tipos
**** Alguma funções já prontas como div(), typeof(), parse(), string(), println(), etc
**** como fazer as nossas funções com a palavra reservada function e que termina por end
***** lembrando que a função pode ou não devolver algo através do return
***** lembrando também que uma função pode chamar outra função
**** como mudar o fluxo de execução normal com o if, elseif


Mas, agora vem a dúvida, uma função pode se chamar?

#+NAME: e3d35c28-d40a-4ce2-aac4-8bee3537ac95
#+begin_SRC ein-julia :results output :session localhost
function imprime()
  println("Mensagem")
  imprime()
end
#+end_SRC

#+RESULTS: e3d35c28-d40a-4ce2-aac4-8bee3537ac95
: [....]

O resultado da função é curioso, ela vai ficar se chamando até uma memória do computador
acabar (para quem conhece é a pilha ou stack). Mas, será que podemos usar isso de forma
mais inteligente ao nosso favor? Isso é, em algum momento a função teria que parar de se chamar
de forma a não acabar com erro.

Uma forma de se fazer isso é através de um comando como o if, que pode ou não seguir
chamando a função, mas para isso vamos precisar receber um parâmetro.

#+begin_SRC ein-julia :results output :session localhost
function countdown(n)
  println(n)
  if n > 0
    countdown(n-1)
  else
    println("Acabou")
  end
end
countdown(10)
#+end_SRC
 Para entender um pouco melhor o que acontece acima, vamos colocar mais umas
impressões.

 #+begin_SRC ein-julia :results output :session localhost
function countdown(n)
  println(n)
  if n > 0
    println("Vou chamar countdown com n = ", n - 1)
    countdown(n-1)
    println("Voltei da chamada com n = ", n - 1)
  else
    println("Acabou")
  end
end
countdown(10)
 #+end_SRC

Observando a sequência de chamadas, fica claro como funciona o computador, de alguma forma,
cada uma das chamadas é empilhada (colocada em um estrutura como uma pilha, de livros, mas
no caso de chamadas de função), sendo que no final são desempilhadas.

Vou desenhar para o caso countdown(5).

Essa estrutura é bem poderosa, pois permite que operações sejam executadas um número controlado de vezes.
Voltando ao countdown, imagine que ao invés de imprimir uma mensagem quiséssemos fazer uma conta com o que será
devolvido.

#+begin_SRC ein-julia :results output :session localhost
function soma(n)
  if n > 0
    return n + soma(n - 1)
  else
    return 1
  end
end
soma(10)
#+end_SRC

 Essa estrutura é bastante poderosa e pode ser usada para o cálculo de produto, nesse
caso, a mudança é bem pequena.

Da mesma forma segue um exemplo para o cálculo dos n primeiros elementos da soma
hârmonica.

#+NAME: cde2230d-c34c-424c-85cf-38b66e823af3
#+begin_SRC ein-julia :results output :session localhost
function somaharmonica(atual, n)
  if atual >= n
    return 1.0 / atual
  else
    return 1.0 / atual + somaharmonica(atual + 1, n)
  end
end
somaharmonica(1, 10)
#+end_SRC

#+RESULTS: cde2230d-c34c-424c-85cf-38b66e823af3
: [....]

 O miniEP para a próxima semana será:
****** computar a soma dos n primeiros inversos dos quadrados
****** computar os n primeiros elementos da soma harmônica alternada, onde os elementos 1/n são somados com sinais alternantes. Para isso um dos parâmetros a serem passados será o sinal.

Em alguns casos é relativamente fácil pensar em testes para verificar se as funções feitas estão corretas. A forma mais fácil de se fazer isso é através de resultados conhecidos.
Por exemplo a soma alternada e o ln 2.
** Aula 10 - <2020-04-12 dom>

*** Agora na linha de comando
  Hoje, vamos continuar fazendo exercícios com Julia, a diferença é que agora vamos usar
a linha de comando, isso é, vamos criar arquivos fora do ambiente "seguro" do Jupyter.
Para isso, vamos criar arquivos com a extensão .jl com código. Vamos começar criando um
arquivo imprime.jl com apenas um print

  #+begin_SRC ein-julia :results output :session localhost
println("Agora do arquivo")
  #+end_SRC

  Ele pode ser compilado/executado chamando se julia imprime.jl

  Da mesma forma podemos usar arquivos para guardar funções como a
  de cálculo de potências inteiras, que recebe um valor x, e devolve $x^ n$.

  #+begin_SRC ein-julia :results output :session localhost
  function pot(x, n)
    res = 1
    while n > 0
      res = res * x
      n = n - 1
    end
    return res
  end
  #+end_SRC

 Mas, como podemos usar essa função, agora que ela está pronta? Usando o comando
include, há formas mais sofisticadas de usar "pacotes", mas por enquanto esse comando
será suficiente.

 #+begin_SRC ein-julia :results output :session localhost
include("funct.jl")
println("2 elevado a 4 é ", pot(2, 4)
 #+end_SRC

Isso inclusive nos ajuda no que se refere aos testes automatizados, pois o
arquivo com os testes automatizados pode ser executado de forma independente.

Sim, podemos incluir novas funções no arquivo funct.jl, como o cálculo de
fatorial.

Os testes de potência a fatorial podem ser independentes!

Agora que temos as funções de cálculo de potência e de fatorial, podemos usá-las
para cálculos mais sofisticados como o de cosseno, usando séries de Taylor:
\[ \mbox{cos}(x) = \Sum_{n = 0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} \], sendo que o valor de $x$ é
dado em radianos.

#+begin_SRC ein-julia :results output :session localhost
include("funct.jl")
function cosseno(x)
  Erro = 1f-7
  série = 0
  termo = 1
  i = 0
  while abs(termo > Erro)
     série = série + termo
     i = i + 1
     termo = potencia(-1, i) * potencia(x, 2 * i) / fat(2 * i)
  end
  série = série + termo
  return série
end
#+end_SRC

Mas, podemos melhorar a nossa função de cálculo de cosseno observando que
dá para a partir do termo anterior, chegar ao próximo termo.


#+begin_SRC ein-julia :results output :session localhost
# aqui vai o código
#+end_SRC

Agora uma discussão sobre uma dúvida que apareceu para o monitor, a identação. Isso
é o recuo que fazemos para delimitar blocos de código em Julia. Vamos ver um exemplo:

#+begin_SRC ein-julia :results output :session localhost
function matematica()
   i = 1
   while i < 100
      if i % 2 == 0
         println(i, " é par ")
      else
         if i % 3 == 0
            print(i, " é divisível por três e ")
            soma = 0
            aux = i
            while aux > 0
               soma = soma + aux % 10
               aux = div(aux, 10)
            end
            if soma % 3 == 0
               println(" e a soma dos seus dígitos também")
            else
               println("Deu ruim, resultado não esperado para: ", i)
               break # sim esse break é justificado :)
            end
         end
      end
      i = i + 1
   end
end
#+end_SRC

Além dos blocos, também é interessante entender o conceito de escopo, vamos a um exemplo:

#+begin_SRC ein-julia :results output :session localhost
function valeum(a)
   println("a valia: ", a)
   a = 1
   println("agora a vale ", a)
end
function avaleum()
   # não imprime a aqui, pois daria erro
   a = 1
   println("a vale: ", a)
end

function vamosver()
   a = 3
   println("a vale: ", a)
   begin
     println("Modifiquei a em um bloco")
     a = 2
     println("a vale: ", a)
   end
   println("O a vale, fora do bloco ", a)
   valeum(a)
   println("a vale: ", a)
   avaleum()
   println("a vale: ", a)
end
#+end_SRC

 No código acima, podemos ver duas coisas importantes, o escopo (valor de uma variável
vai além dos blocos, pois ao modificar dentro de um bloco, modificamos a variável original.
 Por outro lado, o escopo é independente conforme a função.

 Ao chamar uma função com uma variável é passada uma cópia da variável, que é no início da
função igual ao valor original.

 Um exercício para terminar. Dado um número $n$ sabe-se que $n^3$ pode ser representado pela
soma de $n$ números ímpares consecutivos, encontre esses valores para $n$ de 1 a 10.
** Aula 11 - <2020-04-22 qua>
*** Entrada de dados e o começo de listas
Nessa aula, temos dois tópicos principais, como fazer a entrada de dados,
através de comandos de entrada e com argumentos. Além disso também veremos
como tratar de um tipo especial de variável, onde é possível, guardar
mais de um valor.

**** O comando input
Quando queremos inserir dados, em Julia, tanto no Jupyter, como no mode
interativo, basta colocar dados. Mas, como podemos fazer para entrar
dados em um programa comum?

 Para isso temos o comando readline(), que interrompe a execução do
programa e espera pela entrada de uma String, o que ocorre quando a
tecla <enter> é pressionada.

 #+begin_SRC ein-julia :results output :session localhost
println("Digite o seu nome")
resposta = readline()
println("O seu nome e: ", resposta)
 #+end_SRC

Como o readline() lê Strings, se quisermos ler números, é
necessário usar o comando parse.

#+begin_SRC ein-julia :results output :session localhost
println("Digite um inteiro")
valor = parse(Int64, readline())
println("O numero digitado foi ", valor)
#+end_SRC

Sabendo ler números do teclado, vamos a um exercício simples, ler uma
sequência de números inteiros terminada por zero e devolver a sua soma.

#+begin_SRC ein-julia :results output :session localhost
# coloque a sua proposta aqui
#+end_SRC

**** Lendo através da linha de comando
 A outra forma de ler comandos é através da constante ARGS que é
preparada na chamada de um programa. Para entender melhor isso, vamos
ver o seguinte programa.

 #+begin_SRC ein-julia :results output :session localhost
println(ARGS)
 #+end_SRC

Se a linha acima está no arquivo args.jl, ao chamar julia args.jl com diversos
parâmetros, teremos diversos resultados diferentes.

Por exemplo ao chamar:

julia args.jl 1 2 3 abc

Teremos como resposta

#+begin_SRC ein-julia :results output :session localhost
["1", "2", "3", "abc"]
#+end_SRC

Vamos analisar um pouco melhor essa resposta observando que cada
parâmetro está em uma posição.

#+begin_SRC ein-julia :results output :session localhost
tam = length(ARGS)
println("O tamanho dos argumentos é: ", tam)
for i in 1:tam
  println(ARGS[i])
end
#+end_SRC

 Olhando o código acima, podemos ver que o comando length() devolve
o número de argumentos, ou seja, o tamanho da lista ARGS. Além disso
com os colchetes é possível acessar a cada posição da lista de forma
individual.


 O exemplo abaixo  soma os parâmetros inteiros dados como argumentos. Ele
também ilustra uma boa prática que é, sempre colocar o código em módulos,
no caso abaixo em funções:

 #+begin_SRC ein-julia :results output :session localhost
function main()
  tam = length(ARGS)
  s = 0
  i = 1
  while i <= tam
      valor = parse(Int, ARGS[i])
      println(valor)
      s = s + valor
      i = i + 1
  end
  println("A soma foi: ", s)
end
main()

 #+end_SRC

 A flexibilidade que temos ao usar listas é enorme! Por isso,
listas ou vetores, merecem um tópico próprio.

**** Listas

Vamos primeiro brincar um pouco no console.

#+begin_SRC ein-julia :results output :session localhost
vetor = [1, 2, 3]
println(vetor[1])
println(length(vetor))
vetor[2] = vetor[2] + 1
vetor[1] = 2 * vetor[3]
println(vetor)
#+end_SRC

 Como disse antes, o for foi feito para manipular vetores,
vamos ver umas funções, a primeira que imprime os elementos de um vetor
um por linha.

 #+begin_SRC ein-julia :results output :session localhost
function imprimeVetor(v)
  for el in v
    println(el)
  end
end
 #+end_SRC

 Isso também pode ser feito através dos índices do vetor:

 #+begin_SRC ein-julia :results output :session localhost
function imprimeVetor(v)
  for i in 1:lenght(v)
    println(v[i])
  end
end
 #+end_SRC

Como cada posição é independente, podemos calcular a soma dos
elementos ímpares de um vetor

#+begin_SRC ein-julia :results output :session localhost
function somaImpVetor(v)
         soma = 0
         for i in 1:length(v)
           if v[i] % 2 == 1
             soma = soma + v[i]
           end
         end
         return soma
       end
#+end_SRC

Para terminar, vamos fazer uma função onde dado um vetor de inteiros
de tamanho $n$, verifica se esse vetor é uma permutação dos números de
1 a $n$. Para isso, veremos se cada número de 1 a $n$ está no vetor.

#+begin_SRC ein-julia :results output :session localhost
function permuta2(v)
   tam = length(v)
   for i in 1:tam
      if  !(i in v)
         return false
      end
   end
   return true
end
#+end_SRC

Foi usado o comando in de Julia que verifica se um elemento está no vetor.
** Aula 12 - <2020-04-27 seg>
*** Conhecendo melhor os vetores
**** Passar vetores como parâmetro é diferente
Assim como já passamos variáveis normais, ou escalares, como
parâmetro de funções, também podemos passar vetores. Mas, é importante
ressaltar que isso ocorre de forma distinta, isso é, os vetores são
passados por referência.

Vamos a uma analogia, quando se passa uma variável escalar, como
parâmetro a função recebe uma cópia dela. Já para um vetor, o que se
recebe é uma cópia do endereço dele. Em algumas linguages como C, isso
é completamente explícito, e essa referência é denominada ponteiro.

#+begin_SRC ein-julia :results output :session localhost
function mudavalores(x, v)
   println("x = ", x, " e v = ", v)
   x = 1
   v[1] = 1
   println("x = ", x, " e v = ", v)
end
function vesemuda()
   x = 0
   v = [2, 3, 4]
   println("x = ", x, " e v = ", v)
   println("Antes da mudavalores")
   mudavalores(x, v)
   println("Depois da mudavalores")
   println("x = ", x, " e v = ", v)
end
#+end_SRC

Ao executar a função vesemuda(), podemos ver que como esperado para
a variável escalar, no escopo da função a cópia foi alterada, sem
mudança na variável $x$ original.

 Por outro lado, para o vetor, como tínhamos uma cópia do endereço,
mudar sua primeira posição, fez com que o vetor original fosse alterado.
Mas, alterar a cópia do endereço, não muda o endereço final, como pode
se ver abaixo:

 #+begin_SRC ein-julia :results output :session localhost
function novovetor(v)
   println("O vetor era = ", v)
   v = ["a", "b", "c"]
   println("O vetor ficou sendo = ", v)
end
function vesemuda2()
   v = [2, 3, 4]
   println("v = ", v)
   println("Antes de novovetor")
   novovetor(v)
   println("Depois de novovetor")
   println("v = ", v)
end
 #+end_SRC

**** Vamos continuar vendo como manipular vetores

Para isso, vamos precisar conhecer algo de Julia, que vai
nos ajudar. Por enquanto já sabemos como acessar posições específicas
de um vetor.

Mas, vamos precisar de alguns comandos adicionais para fazer
os próximos exercícios. São eles, criar um vetor vazio, adicionar um
ou mais elementos ao final do vetor, e criar um vetor de um tamanho
definido.

#+begin_SRC ein-julia :results output :session localhost
v = [] # define um vetor vazio
push!(v, 1)  # adiciona um primeiro elemento 1 ao vetor
push!(v, 2, 3) # adiciona os elementos 2 e 3 ao vetor
zeros(Int, 3) # cria um vetor para guardar inteiros com 3 posições
zeros(Float, 10) # cria um vetor para guardar floats com 10 posições
#+end_SRC

Nós já vimos que usualmente vetores em Julia podem guardar qualquer
tipo de variável, mas já é bom saber que ao usarmos um vetor com
tipo pré-identificado, isso é, por exemplo, só de inteiros. Seu
uso fica mais eficiente.

Vamos agora exercitar um pouco o uso de vetores:

Faça uma função inverte que dado um vetor, devolve esse vetor com os
valores invertidos (isso é, quem estava na primeira posição vai para
a última e assim por diante).

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

Faça uma função que recebe um vetor de inteiros e devolve um vetor
apenas com os números ímpares do vetor original

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

 Dado um vetor de números inteiros, faça uma função que devolve um vetor que
 corresponde a uma leitura desse vetor, conforme o número de elementos. Ou seja,
 dado o vetor [1, 1, 1, 4, 10, 10, 1] o vetor de saída dever ser [3, 1, 1, 4, 2,
 10, 1, 4] ou seja, três "1", um "4", dois "10" e um "quatro".

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC
Sabendo que o comando rand(1:n), vai devolver um número entre 1 e n.
Escreva uma função que dado um inteiro n, devolve um vetor com uma
permutação de 1 a n.

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

Voltando ao exercício da aula passada vamos ver como fazer com
que a verificação se um vetor corresponde a uma permutação de forma mais
eficiente. Como você faria isso
** Aula 16 <2020-05-06 qua>
*** Um pouco mais de sintaxe de Julia e vetores

Como é de se imaginar, testes automatizados são muito
utilizados por bons desenvolvedores. Logo podemos imaginar
que a linguagem Julia tem formas de ajudar a escrita de
testes.

Isso é feito com o pacote de testes de Julia, para usá-lo precisamos
usar o comando using. Vamos a um exemplo abaixo:
#+begin_SRC ein-julia :results output :session localhost
using Test
@test 1 == 1
@test 1 != 2
#+end_SRC

 O comando @test avalia a expressão e verifica se o valor é
verdadeiro (true), se for, não faz nada. Mas, se não for, aponta
o erro.

 Dessa forma, podemos escrever testes em Julia de forma mais compacta.
Para começar vamos verificar se uma função que recebe um vetor e devolve
a soma dos seus elementos funciona.

 #+begin_SRC ein-julia :results output :session localhost
using Test
include("soma.jl")
function testaTudo()
  @test soma([]) == 0
  @test soma([1]) == 1
  @test soma([10, 20, 30]) == 60
  println("final dos testes")
end
testaTudo()
 #+end_SRC
Que funciona verifica se a seguinte função funciona:

#+begin_SRC ein-julia :results output :session localhost
function soma(v)
  s = 0
  for el in v
    s = s + el
  end
  return s
end
#+end_SRC

 Outro comando útil de Julia é a verificação aproximada, pois já
vimos que operações com número reais nem sempre é exata. Essa
comparação é dada com \approx (barra approx)

 #+begin_SRC ein-julia :results output :session localhost
 0.2 + 0.2 + 0.2 \approx 0.6
 #+end_SRC

*** Voltando a vetores

Vamos agora voltar à parte algorítmica, com o seguinte problema.
Subsequência de soma máxima. Dado um vetor de inteiros, devolver a
soma de elementos consecutivos que seja máxima.

Vamos começar pelos testes.

#+begin_SRC ein-julia :results output :session localhost
using Test
function verificaSoma()
  @test somasub([]) == 0
  @test somasub([1, 2, 3]) == 6
  @test somasub[-1, -2, -3]) == -1
  @test somasub([10, 5, -17, 20, 5, -1, 3, -30, 10]) == 72
  @test somasub([31, -41, 59, 26, -53, 58, 97, -93, -23, 84] == 187
  println("Final dos testes")
end
#+end_SRC

 Vamos começar com a solução de força bruta, isso é, calcular a soma
de todas a sub-sequências, procurando pela máxima.

 #+begin_SRC ein-julia :results output :session localhost
# lugar para escrever o codigo
 #+end_SRC

Agora vamos a um algoritmo mais elaborado. (Jay-Kadane)
#+begin_SRC ein-julia :results output :session localhost
function somasub(v)
  if length(v) == 0
    return 0
  end
  soma = 0
  somamax = v[1]
  for i in 1:length(v)
    if soma + v[i] < 0
      soma = 0
    else
      soma = soma + v[i]
    end
    if soma > somamax
      somamax = soma
    end
  end
  return somamax
end
#+end_SRC

Faça uma função, onde dados dois vetores u e v, devolve o seu
produto escalar.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

 Faça uma função, onde dados dois vetores ordenados u e v,
sem repetição, devolve o vetor ordenado com os elementos de u
e v, sem repetição.

 #+begin_SRC ein-julia :results output :session localhost

 #+end_SRC

** Aula 17 <2020-05-18 seg>
*** Um pouco mais de manipulação de vetores (com merge e busca) e mudança de base
Na aula passada, vimos como fazer um dos problemas de merge, isso, é
dados dois vetores ordenados sem repetição, devolver um vetor que
corresponda a união deles sem repetição.
#+begin_SRC ein-julia :results output :session localhost
function merge(u, v)
  pu = 1   # ponteiro em u
  pv = 1   # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
       push!(resp, u[pu])
       pu = pu + 1
    elseif v[pv] < u[pu]
       push!(resp, v[pv])
       pv = pv + 1
    else
       push!(resp, v[pv])
       pu = pu + 1
       pv = pv + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
  end
  return resp
end
#+end_SRC

Com pequenas variações nesse código, podemos fazer outros tipos de merge:
- Fazer a intersecção
- Fazer a diferença (isso é, elementos devolver apenas elementos que estão
em u, mas não e, v

Todas essas soluções se baseiam em variações do código acima. Tudo isso
sabendo que os vetores originais estão ordenados e sem repetição.

Aproveitando, como podemos fazer para dado um vetor ordenado, com repetições,
devolver um vetor ordenado sem repetições?

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

A ordenação também pode ser útil para verificar se um elemento está em
um vetor, mas vamos começar com a versão simples, de percorrer todo o vetor.

Para isso, faremos uma função que recebe um vetor e um elemento, caso o
elemento pertença ao vetor, devolvemos sua posição, caso contrário devolvemos
0.

#+begin_SRC ein-julia :results output :session localhost
function posicaonovetor(v, el)
  for i in 1:length(v)
    if el == v[i]
      return i
    end
  end
  return 0
end
#+end_SRC

A solução acima funciona, mas ela não considera que o vetor está ordenado.
Para tentar entender uma solução melhor (busca binária), vamos fazer uma
brincadeira. Um voluntário vai pensar em um número entre 0 e 1023 e vou
advinhá-lo em até 10 tentativas, sendo que as respostas podem ser:
- Número encontrado
- O número que eu pensei é maior
- O número que eu pensei é menor

A lógica por trás dessa solução é que eu quero eliminar a maior quantidade
de números a cada palpite, para fazer isso, o melhor é pensar em um
palpite no "meio", que elimine metade dos números em questão.

Vamos agora desenvolver um algoritmo que faz a busca binária.
Mas, como ele é um pouco mais complicado, vamos começar com os testes,
validar os testes com a função anterior (posição no vetor) e finalmente
escrever o nosso algoritmo de busca binária.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Na aula que vem veremos algumas formas de se ordenar um vetor,
sim Julia tem as funções sort() e sort!(). Mas, a motivação por
trás de aprender a ordenar é aprender como fazê-lo.

*** Mudança de base
Vamos começar com umas ideias intuitivas, na base 10, temos os
dígitos de 0 a 9, e os números são agrupados de forma que o menos
significativo corresponde à base 10^0, o segundo à base 10¹ e assim
por diante.

Logo, um número como o 123 é na verdade igual a 3 * 10⁰ + 2 * 10¹ + 1*10².
Isso é tão natural que usamos naturalmente, sem pensar em base quando
falamos em base decimal.

O mesmo vale para outras bases, como a binária:

10010 é igual a 0 * 2^0 + 1 * 2^1 + 0 * 2^2 + 0 * 2^3 + 1 * 2^4 ou seja é
igual a 18 na base 10.

Dessa forma, podemos pensar em como devolver o valor na
base 10, para um número qualquer na base 2.

#+begin_SRC ein-julia :results output :session localhost
function valorbase2(n)
  pot = 0
  soma = 0
  while n != 0
    dig = n % 10
    soma = soma + dig * 2 ^pot
    n = n ÷ 10
    pot = pot + 1
  end
  return soma
end
#+end_SRC

Há duas coisas a observar acima, o código pode ser melhorado e
podemos pensar em outras bases que não sejam apenas a binária (a
dificuldade de trabalhar com bases maiores do que 10 é devido
às variáveis inteiras terem apenas os dígitos de 0 a 9).

Mas, vamos fazer isso de uma forma iterativa, usando testes
 automatizados.

Após vermos como ter um número em uma base menor, na base 10,
vamos ver como transformar um número na base 10, em outra base.
Comecemos com a binária:

Temos as potências: 1, 2, 4, 8, 16, 32, 64, ...
Como escrever o número 99 em binário?
Começamos pela parte menos significativa, isso é, 99 % 2, e continuamos
com a sobra da parte mais significativa, isso é, 99 % 2 (= 1) e
 99 \div 2 (= 49), e repetimos o mesmo procedimento.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Mas, não vamos esquecer dos nossos testes :)

Olhando os códigos com cuidado, dá para generalizar?

** Aula 18 - Simulado de prova <2020-05-20 qua>
*** Prova de 2019 (traduzida de C para Julia)
**** Questão 1 (1.5 pontos)
Dado o seu NUSP qual é a saída do programa abaixo?
#+begin_SRC ein-julia :results output :session localhost
function misterio(n)
   b = n
   c = -1
   while b > 0
      a = b % 10
      b = b ÷ 10
      if a > c
         c = a
      end
      x = float(b / 10)
      println("n = ", n, "  a = ", a, "  b = ", b, "  c = ", c, "  x = ", x)
   end
   println("c = ", c, " n/100 ", n/100)
end
#+end_SRC

**** Questão 2 (2.5 pontos)
Um número inteiro n > 0 é perfeito se ele for igual à soma de seus divisores
positivos diferentes de n.

Exemplo:
-  6 é perfeito, pois 6 = 1 + 2 + 3;
-  28 é perfeito, pois 28 = 1 + 2 + 4 + 7 + 14.

Faça uma função que recebe um número inteiro n > 0 e decide se n é perfeito.

**** Questão 3 (2.5 pontos)
Dado um vetor n números inteiros, desejamos encontrar o comprimento
de um maior segmento crescente da sequência.
Exemplo:
- para o vetor v = [4, 7, 2, 4, 7, −2, 5, 8, 1, 17]
um maior segmento crescente tem comprimento 3.
- para o vetor v = [10, 10, 5, 3, 2]
um maior segmento crescente tem comprimento 1.
- para o vetor v = [2, 7, 5, 6, 8, 13, 9, 11, 2, 5, 7, 4, 13]
um segmento crescente de comprimento máximo tem tamanho 4.

**** Questão 4 (3.5 pontos)

Dizemos que um número inteiro n é 3-alternante se, quando n é escrito
 na base 3, alterna números pares e ı́mpares.
Exemplo:
- 151 é 3-alternante, pois 151 escrito na base 3 é 12121 que alterna pares e ı́mpares.
- 145 é 3-alternante, pois escrito na base 3 é 12101, que alterna pares e ı́mpares.
- 48 é 3-alternante, pois escrito na base 3 é 1210.
- 37 não é 3-alternante, pois escrito na base 3 é 1101.
- 2 é 3-alternante, pois se escreve 2 na base 3.
Faça uma função que lê um inteiro n ≥ 0 e verifica se n é 3-alternante.

** Aula 19 - Ordenação

Tem que colocar conteúdo aqui

** Aula 20 - Ainda ordenação

Nessa aula vamos continuar vendo a ordenação, mas antes disso,
vamos finalmente ver o algoritmo de busca binária para
encontrar um elemento em um vetor ordenado.

*** Busca binária
Ao invés de percorrer o vetor, desde o início, procurando o
elemento como em:
#+begin_SRC ein-julia :results output :session localhost
function buscaLinear(x, v)
  for i in 1:length(v)
    if v[i] == x
      return i
    end
  end
  return 0 # não encontrou o x em v[]
end
#+end_SRC

Podemos a cada procura, para ver se o elemento está
no vetor, eliminar metado do vetor. Se o elemento for
menor que o meio, olhamos do começo ao meio. se for maior
que o meio, olhamos do meio ao fim. Se for igual, achou.

#+begin_SRC ein-julia :results output :session localhost
function buscaBinaria(x, v)
   inicio = 1
   fim = length(v)
   while in <= fim
      meio = div(inicio + fim, 2)
      if v[meio] == x
        return meio
      elseif x < v[meio]
        fim = meio - 1
      else
        inicio = meio + 1
      end
   end
   return 0
end
#+end_SRC

 Há também a versão recursiva, para isso temos que ter
o inĩcio e o fim como parâmetros.

#+begin_SRC ein-julia :results output :session localhost
function buscaBinariaRec(inicio, fim, x, v)
   if inicio > fim
     return 0
   end
   meio = div(inicio + fim, 2)
   if v[meio] == x
     return meio
   elseif x < v[meio]
     buscaBinariaRec(inicio, meio - 1, x, v)
   else
     buscaBinariaRec(meio + 1, fim, x, v)
   end
end
#+end_SRC

*** Métodos de busca mais elaborados

Uma forma mais eficiente de se ordenar um vetor é usando a divisão e conquista,
isso é, dado um vetor, quebramos em duas partes, ordenamos as partes e depois
fazemos o merge, no caso como podemos ter repetição, vamos usar a versão que
permite duplicação.

#+begin_SRC ein-julia :results output :session localhost
function merge(u, v)
  pu = 1  # ponteiro em u
  pv = 1  # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
      push!(resp, u[pu])
      pu = pu + 1
    elseif v[pv] < u[pu]
      push!(resp, v[pv])
      pv = pv + 1
    else
      push!(resp, v[pv])
      pu = pu + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
    end
  return resp
end
#+end_SRC

 Dado o merge, a ideia é:
- Divida o vetor no meio
- Ordene cada metade separadamente
- Devolva o merge

Para isso vamos ver mais uma possibilidade de Julia,
dado um vetor v, v[1:meio] cria um vetor até o meio e
v[meio + 1:length(v)] cria um vetor do meio + 1 ao final.

Com isso fica fácil fazer o mergeSort.

#+begin_SRC ein-julia :results output :session localhost
function mergeSort(v)
  if length(v) <= 1
    return v
  end
  meio = div(length(v), 2)
  v1 = v[1:meio]
  v2 = v[meio + 1:length(v)]
  v1ord = mergeSort(v1)
  v2ord = mergeSort(v2)
  return merge(v1ord, v2ord)
end
#+end_SRC

 Vamos ao último algoritmo, que também fica melhor de forma
recursiva, dado um vetor, o primeiro passo é escolher um elemento
 de forma a dividir o vetor em duas partes, quem for menor ou
igual a esse elemento, e quem for maior. Isso deve ser feito
de forma recursiva.

#+begin_SRC ein-julia :results output :session localhost
function quick!(i, j, v)
    if j > i
        pivo = v[div(i+j, 2)]
        left = i
        right = j
        while left <= right
            while v[left] < pivo
                left += 1
            end
            while v[right] > pivo
                right -= 1
            end
            if left <= right
                v[left], v[right] = v[right], v[left]
                left += 1
                right -= 1
            end
        end
        quick!(i, right, v)
        quick!(left, j, v)
    end
    return v
end
#+end_SRC
** Aula 21 - Indo além de vetores
Nessa aula o objetivo é ir além de vetores, primeiro entendendo que em
Júlia o que se pode fazer com vetores é bem flexível, em seguida vamos
ver que vetores podem ter várias dimensões. Veremos ao final alguns algoritmos
com matrizes.

*** Indo além de vetores
Conforme já vimos antes, os vetores ocupam várias posições de
memória, uma forma de se inicializar um vetor é através da função
zeros. Que cria um vetor com valores nulos.

#+begin_SRC ein-julia :results output :session localhost
zeros(1)
zeros(100)
zeros(Int8, 3)
#+end_SRC

A novidade é que agora o zeros pode criar também vetores de mais
de uma dimensão, ou matrizes.
#+begin_SRC ein-julia :results output :session localhost
zeros(3,3)
zeros(Int, 2, 2)
#+end_SRC

Duas outras funçÕes interessantes são a ones() com comportamento
similar a zeros(), e a rand() que cria vetores ou matrizes com
números aleatórios.

O comando fill() serve para fazer isso com um valor específico.
#+begin_SRC ein-julia :results output :session localhost
ones(3, 3)
rand(4, 4)
rand(1: 10, 5, 5)
fill(42, 3, 3, 3)
#+end_SRC

Também é possível criar matrizes diretamente.

#+begin_SRC ein-julia :results output :session localhost
m = [1 2 3; 4 5 6; 7 8 9]
#+end_SRC

O comando length() funciona para matrizes, mas devolve o seu tamanho
total, mas temos também os comandos ndims() e size().


A linguagem Julia ainda oferece vários açucares sintáticos, vejamos o
exemplo abaixo.
#+begin_SRC ein-julia :results output :session localhost
a = [1 2; 3 4]
b = [1 0; 0 1]
a * b
a .* b
#+end_SRC

Mas, lembrando que o objetivo da disciplina é ensinar algoritmos, vamos
ver alguns.

Uma função que imprime uma matriz quadrada m.

#+begin_SRC ein-julia :results output :session localhost
function imprimeMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          print(" m[", i, ", ", j, "] = ", m[i,j])
        end
        println()
    end
end
#+end_SRC


Faça uma função que recebe uma matriz quadrada e devolve a soma dos seus
elementos.

#+begin_SRC ein-julia :results output :session localhost
function somaMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          soma = soma + m[i, j]
        end
     end
     return soma
  end
#+end_SRC

Uma matriz quadrada é um quadrado mágico se a soma dos elementos de
cada linha, de cada coluna e das diagonais é sempre igual. Faça uma
função que dada uma matriz quadrada m, verifica se ela é um
quadrado mágico.

#+begin_SRC ein-julia :results output :session localhost
function QuadradoMagico(m)
    if length(m) == 1
      return true
    end
    a = size(m)
    if length(a) != 2 || a[1] != a[2]
      return false
    end
    somaP = 0
    for i in 1:a[1]
      somaP = somaP + m[i, i]
    end
    soma = 0
    for i in 1:a[1]
       soma = soma + m[i, a[1] - i + 1]
    end
    if somaP != soma
       return false
    end
    for i in 1:a[1]
       somaL = 0
       somaC = 0
       for j in 1:a[2]
          somaL = somaL + m[i, j]
          somaC = somaC + m[j, i]
       end
       if somaL != somaP || somaC != somaP
          return false
       end
    end
    return true
end
#+end_SRC

** Aula 22 - Ainda matrizes

 Dadas duas matrizes m e n, faça uma função que devolva o
produto delas (sem usar o * para matrizes).

 #+begin_SRC ein-julia :results output :session localhost
function multiplica(a, b)
   dima = size(a)
   dimb = size(b)
   if dima[2] != dimb[1]
     return -1
   end
   c = zeros(dima[1], dimb[2])
   for i in 1:dima[1]
      for j in 1:dimb[2]
         for k in 1:dima[2]
            c[i, j] = c[i, j] + a[i, k] * b[k, j]
         end
       end
   end
   return c
 end

 #+end_SRC

Uma matriz quadrada de tamanho n é um quadrado latino se em cada linha e coluna
aparecem todos os valores de 1 a n. Faça uma função que dada uma matriz
quadrada verifica se ela é um quadrado latino.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Dizemos que uma matriz inteira A nxn  é uma matriz de permutação se em cada linha e em cada
coluna houver n-1 elementos nulos e um único elemento igual a 1. Faça uma função que recebe
uma matriz quadrada e que verifica se ela é uma matriz de permutação.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Mas, conforme a abstração que fazemos as matrizes podem representar coisas diferentes,
por exemplo dada uma matriz quadrada n x n, a posição a[i][j], pode indicar se há um caminho
entre a cidade i e a cidade j.

Da mesma forma, a[i][j] pode representar a distância entre a cidade i e a cidade j. Com isso, podemos
ter problemas mais sofisticados como saber se dá para chegar da cidade i na cidade j, ou o custo
do menor caminho.

Nessa aula, vamos ver, um exemplo mais elaborado do uso de matriz, através de uma teoria conhecida
como percolation. Vamos primeiro entender o que seria isso usando o livro do Sedgewick e do Wayne
https://introcs.cs.princeton.edu/java/24percolation/

A pergunta é saber qual é a probabilidade, a partir da qual a percolation ocorre com grande
chance (digamos mais de 80%, ou seja em 100 tentativas, em 80 ocorre a percolation). Vamos para simplificar
o problema pensar em matrizes 20 por 20.

Como resolver esse problema?


** Aula 25 - C para quem programa em Julia

Como vocês devem lembrar, na primeira aula deixei claro que a linguagem de programação
era apenas o meio de se traduzir algum conceito algorítmico para o computador, de forma
a permitir a sua execução.

Como infelizmente, Julia ainda não é uma linguagem bastante conhecida, várias outras
linguagens mais tradicionais farão compania para vocês no curso. Conhecer várias linguagens
não é ruim, mas por outro lado Julia não ser conhecida é :)

Nessa aula, a ideia é apresentar a linguagem C para quem já programa em Julia. Há algumas
diferenças básicas

*** Compilado versus Interpretada
 Enquanto Julia é uma linguage interpretada, C é uma linguagem compilada, isso é, a partir
de um código fonte, ao se passar pelo compilador, é gerado um código objeto, que se correto,
pode ser executado na arquitetura para qual foi compilado.

Vejamos um primeiro código em C.
#+begin_src C
  #include <stdio.h>
  int main() {
    printf ("Hello World!\n");
  }
#+end_src

Para compilar o código acima, usamos o comando

#+BEGIN_CENTER
gcc um.c
#+END_CENTER
Que vai gerar um arquivo executável a.out, que se chamado imprime
a mensagem. O ponto de entrada inicial de um programa em C é único
e é a função main().

Mas, dá para ver mais umas coisas no código acima que são diferenças
em relação à Julia. Mesmo para coisas básicas como impressão é necessário
incluir bibliotecas, no caso a stdio.h que possui a função printf().

Os blocos são definidos com chaves (abre e fecha) e o ponto e vírgula
delimita os comandos.

Além disso, já dá para ver que C é fortemente tipado, isso é, é necessário
dizer o tipo de tudo ou seja, a função main() acima, não devolve nada.

*** Linguagem Tipada

Para cada variável em C, é necessário definir o seu tipo, vamos a mais
um exemplo:

#+BEGIN_CENTER
 #include <stdio.h>
  void main() {
    int a = 1;
    int b = 2;
    int c;
    c = a + b
    printf ("O valor de c é %d\n", c);
  }

#+END_CENTER

Acima é possível ver que podemos dar o tipo e definir a variável na mesma linha, ou
declarar e depois usar. Não é possível usar uma variável sem declarar explicitamente.
Isso tem vantagens claras, pois possíveis erros podem ser encontrados já em tempo de
compilação, antes da execução.

O comando de impressão também segue uma sintaxe diferente, recebendo primeiro uma
string, e depois uma lista de parâmetros. Nessa string, para saber como imprimir cada um
dos parâmetros e usar %, no caso %d para inteiros, %g para ponto flutuante e %s para string.
O \n no final é um indicativo para pular linha.

A declaração de funções é semelhante, só que para cada variável passada como parâmetro é
necessário passar o seu tipo. Os tipos mais comuns em C são, int, char, float e double.
Não há o tipo boolean em C, o que se faz é usar comparações, ou tipos inteiros, basicamente
0 equivale a falso e outros valores a verdadeiro.

#+BEGIN_CENTER
#include <stdio.h>

int soma(int a, int b){
  return a + b;
}
void main() {
  int a = 1;
  int b = 2;
  printf ("O valor  é %d\n", soma(a, b));
  if (soma(a, b) == 3)
    printf(" Verdade = %d\n", soma(a, b) == 3);  // Bloco sem chaves
}
#+END_CENTER

No código acima podemos ver que se o bloco tem apenas uma instrução,
não precisa usar as chaves.

Assim como em Julia, a recursão também funciona bem em C.

*** Comandos diferentes
Já o for em C é composto por três parâmetros, todos opcionais,
a inicialização, a condição e o passo.

#+BEGIN_CENTER
 #include <stdio.h>
void main(){
  for (int p = 1; p <= 512; p *= 2) {
    printf("%d\n", p);
  }
}   
#+END_CENTER


A sintaxe do if é um pouco diferente, principalmente no que se refere ao
uso de elses. Vejamos um exemplo e aproveitemos para usar o comando de 
entrada de dados pelo teclado, o scanf

Comando switch

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um número: ");
  scanf("%d", &n);
    if (n < 0)
      printf("Número negativo\n");
      else if (n > 0)
        printf("Número positivo\n");
        else
          printf("zero\n");
}    
#+END_CENTER

Observem que quanto mais elses, mais iríamos para a direita, logo isso
se escreve de uma forma alternativa:

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um número: ");
  scanf("%d", &n);
    if (n < 0)
      printf("Número negativo\n");
    else if (n > 0)
      printf("Número positivo\n");
    else
      printf("zero\n");
}    
#+END_CENTER


Mas, o principal acima é o operador &, que obtém o endereço de
uma variável, ou seja a sua posição na memória, podemos ver o efeito
disso na seção abaixo.

Mas, antes um exemplo do uso de switch.

#+BEGIN_CENTER
#include <stdio.h>
void main()
{
    int n;

    printf("Qual a sua carta (1-13)? ");
    scanf("%d", &n);
    switch (n) {
      case  1: printf("Ace\n"); break;
      case 11: printf("Jack\n"); break;
      case 12: printf("Queen\n"); break;
      case 13: printf("King\n"); break;
      default: printf("%d\n", n); 
    }
}
#+END_CENTER
*** Vetores e ponteiros

Vejamos o exemplo abaixo, o primeiro a lidar com ponteiros de forma
mais explícita.

#+BEGIN_CENTER
#include <stdio.h>
void naoModifica(int a){
  a = 2;
}
void Modifica(int *a){
  *a = 2;
}  

void main(){
  int n = 3;

  printf("A variável n vale %d\n", n);
  naoModifica(n);
  printf("A variável n vale %d\n", n);
  Modifica(&n);
  printf("A variável n vale %d\n", n);   
}    
#+END_CENTER

O mais próximo que vimos de ponteiros em Julia foi o
conceito de vetores, onde um vetor também é um ponteiro,
mas que também guarda o seu tamanho.

Vamos a um exemplo de vetores em C.

#+BEGIN_CENTER
#include <stdio.h>
#include <stdlib.h>

void imprimeVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    printf("v[%d] = %d  ",i, v[i]);
  printf("\n");
}

void inicializaVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = rand() % 100;
}

void vezes2Vetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = 2 * v[i];
}



void main()
{
  int vetor[10];
  inicializaVetor(vetor, 10);
  imprimeVetor(vetor, 10);
  vezes2Vetor(vetor, 10);
  imprimeVetor(vetor, 10);  
}
#+END_CENTER

Mas, com grandes poderes vem grandes responsabilidades, veja o programa abaixo com
uma pequena modificação e um erro inserido.
