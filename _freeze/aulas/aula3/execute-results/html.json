{
  "hash": "d4b7f343662b20a3d731e4febe6d5cd2",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nObjetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a noção de variáveis.\n\n## Começando com o modo interativo do Julia\n\nQuem quiser já pode instalar o ambiente de programação, usem esse [link](https://julialang.org/). Há também alguns ambientes que permitem o uso da linguagem no seu navegador, sugiro a busca pelas palavras chave `Julia Language online`.\n\nDentro do Julia (após chamar julia na linha de comando), vamos começar com contas com números inteiros:\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\nSim, como era de se esperar, podemos em Julia usar os operandos: `+`, `-` e `*`, o resultado será como o esperado. Vejamos a seguir que com a divisão fica um pouco diferente:\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n84 / 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\nNotem que nesse caso, houve uma mudança de tipos, pois 84 e 2 são inteiros e o resultado é um número em ponto flutuante (float), podemos ver isso, pois ao invés de 42, tivemos como resultado 42.0.\n\nTambém é possível pedir o resultado inteiro usando o operador `div`:\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o símbolo da divisão é necessário digitar `\\div` seguido da tecla `<tab>`).\n\nAlém das contas básicas, também dá para fazer a exponenciação:\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\nExpressões mais complexas também podem ser calculadas:\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\nSim, a precedência de operadores usual também é válida em Julia. Mas, segue a primeira lição de programação: *Escreva para humanos, não para máquinas*.\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\nEm Julia também podemos fazer operações com números em ponto flutuante:\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\nou\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\nAcima temos mais um exemplo de código escrito para pessoas, ao se escrever 2.0 estamos deixando claro que o segundo parâmetro é um número float.\n\nÉ importante saber que números em ponto flutuante tem precisão limitada, logo não se espante com resultados inesperados como abaixo:\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\nErros como esse são bastante raros, tanto que usualmente confiamos plenamente nas contas feitas com computadores e calculadoras. Mas, é bom saber que existem limitações.\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n\n\nou\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n\n\nou ainda\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\nEsses problemas de precisão estão ligados a limitação de como os números são representados no computador. De maneira simplificada, os valores no computador são codificados em palavras, formadas por bits. Nos computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma outra limitação está ligada aos números inteiros muito grandes\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\nMas, para um curso introdutório basta saber que existem essas limitações. Como lidar com elas é parte de um curso mais avançado.\n\nÉ importante notar que o erro acima é um *erro silencioso*, ou seja quanto estamos usando números inteiros, pode ocorrer que o número a ser representado não caiba no número de bits disponível, o que faz com que ocorra um erro.\n\nVoltando para as contas. Um outro operador interessante é o `%` que faz o resto da divisão\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\nAté agora vimos como trabalhar com um único valor, ou seja, como se fosse no visor de uma calculadora. Mas, é possível ir além. Ao invés de termos teclas de memória, o computador nos oferece variáveis. Elas são como nomes para valores que queremos guardar e usar mais tarde.\n\nAlém das operações básicas também temos as operações matemáticas (funções), como por exemplo o seno, sin em inglês. Para saber como uma função funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender o uso de uma função como sin. Vejamos agora a raiz quadrada:\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\nNela vemos que é possível calcular a raiz como em:\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\nMas, observamos também na documentação a função `big()`, que tem a seguinte ajuda:\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc BigInt\n```\n:::\n\n\n\n\n\nCom números BigInt, já não há problemas de estouro, como podemos ver abaixo:\n\n\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n## Variáveis e seus tipos\n\nEm Julia também temos o conceito de variáveis, que servem para armazenar os diferentes conteúdos de dados possíveis.\n\n\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n\nÉ importante notar que as variáveis em Julia podem receber novos valores e o tipo da variável depende do que foi atribuído por último.\n\n\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\na = 3\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\nAproveitando o momento, podemos ver que há vários tipos primitivos em Julia, sendo os principais:\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\ntypeof(1.1)\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\nFalando em Strings, elas são definidas por conjuntos de caracteres entre aspas como:\n\n\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\nDá também para fazer operações com strings como concatenação:\n\n\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\nOu potência:\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\ns = \"Nao vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa\" ⋯ 98 bytes ⋯ \"s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\nAinda sobre variáveis, há umas regras com relação aos seus nomes, tem que começar com uma letra (ou com `_`), pode ter dígitos e não pode ser uma palavra reservada. É bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o Δ (`\\Delta`):\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\nΔ = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n\n\nMas, a linguagem vai bem além com caracteres de animais e símbolos:\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\n🐱 = 5 # \\:cat: <tab>\n🐶 = 3 # \\:dog: <tab>\n🏠 = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\nIsso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](https://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Saída de dados\nPara fazer saídas usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro não pula linha e o segundo pula.\n\n\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar \"açucares sintáticos\".\n\n\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\nAcima, vimos a forma de se inserir comentários em Julia (sim esses serão ignorados pelo computador).\n\n\nExercício:\nFaça o passo a passo para encontrar as raízes da equação de segundo grau $x^2 - 5 x + 6$, usando\nas váriaveis `a`, `b`, `c`, `\\Delta`, `x1` e `x2`.\n\n",
    "supporting": [
      "aula3_files"
    ],
    "filters": [],
    "includes": {}
  }
}